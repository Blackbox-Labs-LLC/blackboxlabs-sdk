// This file is auto-generated by @hey-api/openapi-ts

import { type Options, getAttachmentStats, downloadAttachment, disable2Fa, enable2Fa, login, logout, register, requestPasswordReset, resendVerification, resetPassword, setup2Fa, verifyEmail, createCheckout, createAdjustment, refundPayment, getPublicConfig, getSubscription, listSubscriptions, createSubscription, changeSubscription, cancelSubscription, resumeSubscription, paddleWebhook, identifyUser, sendMessage, getTicketHistoryPublic, getTicketMessagesPublic, getUserTickets, getUserOrganizations, createOrganization, findOrganizationsByEmailDomain, joinOrganization, getOrganization, acceptInvitation, listEvents, createEvent, exportEvents, getEventStats, streamEvents, wsEvents, wsAuth, getEvent, inviteUser, getMembers, removeMember, updateMembership, deleteMessage, getMessage, getEffectivePermissions, listAgents, heartbeat, listRoles, createRole, deleteRole, getRole, updateRole, assignRole, revokeRole, getAllOrganizationSettings, setOrganizationSetting, applyDataRetention, getOrgEffectiveSettings, deleteOrganizationSetting, getOrganizationSetting, checkBreaches, countdownSse, listPolicies, createPolicy, updatePolicy, syncOps, syncSnapshot, listTags, createTag, getPopularTags, deleteTag, getTag, updateTag, getTagWithTickets, listTeams, createTeam, updateTeam, listMembers, addMember, removeMember2, listTickets, createTicket, bulkUpdateTickets, mergeTickets, splitTicket, listSavedViews, createSavedView, deleteTicket, getTicket, updateTicket, assignTicketTeam, clearTicketTeamAssignment, getTicketTeamAssignment, deleteDraft, getDraft, upsertDraft, getTicketHistory, releaseTicketLock, lockTicket, takeoverTicketLock, listTicketMessages, createMessage, getMessageCount, createInternalNote, getLatestMessage, searchMessages, listMessageAttachments, uploadAttachments, deleteAttachment, removeTagsFromTicket, addTagsToTicket, listTyping, typingUpdate, listTicketWatchers, addTicketWatcher, removeTicketWatcher, listCustomFields, createCustomField, deleteCustomField, listSegments, createSegment, deleteSegment, updateSegment, evaluateSegment, getUserCustomFields, setUserCustomFields, listWebhooks, createWebhook, listWebhookEvents, sendWebhooks, getWebhookStats, deleteWebhook, getWebhook, updateWebhook, testWebhook, getPermissionsCatalog, listSessions, cleanupExpiredSessions, revokeAllSessions, getSessionStats, revokeSession, getSession, extendSession, getSettingsCatalog, deleteAccount, listApiKeys, createApiKey, deleteApiKey, getApiKey, revokeApiKey, getLoginAttempts, getLoginHistory, changePassword, getProfile, updateProfile } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { GetAttachmentStatsData, DownloadAttachmentData, Disable2FaData, Disable2FaError, Disable2FaResponse, Enable2FaData, Enable2FaError, Enable2FaResponse, LoginData, LoginError, LoginResponse, LogoutData, LogoutError, LogoutResponse, RegisterData, RegisterError, RegisterResponse2, RequestPasswordResetData, RequestPasswordResetError, RequestPasswordResetResponse, ResendVerificationData, ResendVerificationError, ResendVerificationResponse, ResetPasswordData, ResetPasswordError, ResetPasswordResponse, Setup2FaData, Setup2FaError, Setup2FaResponse2, VerifyEmailData, VerifyEmailError, VerifyEmailResponse, CreateCheckoutData, CreateCheckoutResponse2, CreateAdjustmentData, CreateAdjustmentResponse, RefundPaymentData, RefundPaymentResponse, GetPublicConfigData, GetSubscriptionData, ListSubscriptionsData, ListSubscriptionsResponse, CreateSubscriptionData, ChangeSubscriptionData, CancelSubscriptionData, ResumeSubscriptionData, PaddleWebhookData, IdentifyUserData, IdentifyUserResponse, SendMessageData, SendMessageResponse, GetTicketHistoryPublicData, GetTicketMessagesPublicData, GetUserTicketsData, GetUserOrganizationsData, CreateOrganizationData, CreateOrganizationResponse, FindOrganizationsByEmailDomainData, JoinOrganizationData, JoinOrganizationResponse, GetOrganizationData, AcceptInvitationData, AcceptInvitationResponse, ListEventsData, ListEventsError, ListEventsResponse, CreateEventData, CreateEventError, CreateEventResponse, ExportEventsData, GetEventStatsData, StreamEventsData, WsEventsData, WsAuthData, GetEventData, InviteUserData, InviteUserResponse, GetMembersData, RemoveMemberData, RemoveMemberResponse, UpdateMembershipData, UpdateMembershipResponse, DeleteMessageData, DeleteMessageError, DeleteMessageResponse, GetMessageData, GetEffectivePermissionsData, ListAgentsData, HeartbeatData, HeartbeatResponse, ListRolesData, CreateRoleData, CreateRoleResponse, DeleteRoleData, DeleteRoleResponse, GetRoleData, UpdateRoleData, UpdateRoleResponse, AssignRoleData, AssignRoleResponse, RevokeRoleData, RevokeRoleResponse, GetAllOrganizationSettingsData, SetOrganizationSettingData, SetOrganizationSettingResponse, ApplyDataRetentionData, ApplyDataRetentionResponse, GetOrgEffectiveSettingsData, DeleteOrganizationSettingData, DeleteOrganizationSettingResponse, GetOrganizationSettingData, CheckBreachesData, CheckBreachesResponse, CountdownSseData, ListPoliciesData, CreatePolicyData, CreatePolicyResponse, UpdatePolicyData, UpdatePolicyResponse, SyncOpsData, SyncOpsResponse2, SyncSnapshotData, ListTagsData, ListTagsResponse, CreateTagData, CreateTagResponse, GetPopularTagsData, DeleteTagData, DeleteTagResponse, GetTagData, UpdateTagData, UpdateTagResponse, GetTagWithTicketsData, GetTagWithTicketsResponse, ListTeamsData, CreateTeamData, CreateTeamResponse, UpdateTeamData, UpdateTeamResponse, ListMembersData, AddMemberData, AddMemberResponse, RemoveMember2Data, RemoveMember2Response, ListTicketsData, ListTicketsError, ListTicketsResponse, CreateTicketData, CreateTicketError, CreateTicketResponse, BulkUpdateTicketsData, MergeTicketsData, SplitTicketData, SplitTicketResponse, ListSavedViewsData, CreateSavedViewData, CreateSavedViewResponse, DeleteTicketData, DeleteTicketError, DeleteTicketResponse, GetTicketData, UpdateTicketData, UpdateTicketError, UpdateTicketResponse, AssignTicketTeamData, AssignTicketTeamError, AssignTicketTeamResponse, ClearTicketTeamAssignmentData, ClearTicketTeamAssignmentResponse, GetTicketTeamAssignmentData, DeleteDraftData, DeleteDraftResponse, GetDraftData, UpsertDraftData, UpsertDraftResponse, GetTicketHistoryData, ReleaseTicketLockData, ReleaseTicketLockResponse, LockTicketData, TakeoverTicketLockData, ListTicketMessagesData, ListTicketMessagesError, ListTicketMessagesResponse, CreateMessageData, CreateMessageError, CreateMessageResponse, GetMessageCountData, CreateInternalNoteData, CreateInternalNoteResponse, GetLatestMessageData, SearchMessagesData, SearchMessagesError, SearchMessagesResponse, ListMessageAttachmentsData, UploadAttachmentsData, UploadAttachmentsError, UploadAttachmentsResponse, DeleteAttachmentData, DeleteAttachmentError, DeleteAttachmentResponse, RemoveTagsFromTicketData, RemoveTagsFromTicketError, RemoveTagsFromTicketResponse, AddTagsToTicketData, AddTagsToTicketError, ListTypingData, TypingUpdateData, TypingUpdateResponse, ListTicketWatchersData, AddTicketWatcherData, AddTicketWatcherResponse, RemoveTicketWatcherData, RemoveTicketWatcherResponse, ListCustomFieldsData, CreateCustomFieldData, CreateCustomFieldResponse, DeleteCustomFieldData, DeleteCustomFieldResponse, ListSegmentsData, CreateSegmentData, CreateSegmentResponse, DeleteSegmentData, DeleteSegmentResponse, UpdateSegmentData, UpdateSegmentResponse, EvaluateSegmentData, EvaluateSegmentResponse2, GetUserCustomFieldsData, SetUserCustomFieldsData, SetUserCustomFieldsResponse, ListWebhooksData, ListWebhooksError, ListWebhooksResponse, CreateWebhookData, CreateWebhookError, CreateWebhookResponse, ListWebhookEventsData, SendWebhooksData, SendWebhooksResponse, GetWebhookStatsData, DeleteWebhookData, DeleteWebhookResponse, GetWebhookData, UpdateWebhookData, UpdateWebhookResponse, TestWebhookData, TestWebhookResponse, GetPermissionsCatalogData, ListSessionsData, CleanupExpiredSessionsData, RevokeAllSessionsData, GetSessionStatsData, RevokeSessionData, GetSessionData, ExtendSessionData, ExtendSessionResponse, GetSettingsCatalogData, DeleteAccountData, DeleteAccountResponse, ListApiKeysData, ListApiKeysError, ListApiKeysResponse, CreateApiKeyData, CreateApiKeyError, CreateApiKeyResponse2, DeleteApiKeyData, DeleteApiKeyResponse, GetApiKeyData, RevokeApiKeyData, RevokeApiKeyResponse, GetLoginAttemptsData, GetLoginHistoryData, ChangePasswordData, ChangePasswordError, ChangePasswordResponse, GetProfileData, UpdateProfileData, UpdateProfileResponse } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getAttachmentStatsQueryKey = (options?: Options<GetAttachmentStatsData>) => createQueryKey('getAttachmentStats', options);

export const getAttachmentStatsOptions = (options?: Options<GetAttachmentStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAttachmentStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAttachmentStatsQueryKey(options)
    });
};

export const downloadAttachmentQueryKey = (options: Options<DownloadAttachmentData>) => createQueryKey('downloadAttachment', options);

export const downloadAttachmentOptions = (options: Options<DownloadAttachmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await downloadAttachment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: downloadAttachmentQueryKey(options)
    });
};

export const disable2FaQueryKey = (options?: Options<Disable2FaData>) => createQueryKey('disable2Fa', options);

/**
 * Disable 2FA
 * Disable TOTP-based 2FA for the authenticated user.
 */
export const disable2FaOptions = (options?: Options<Disable2FaData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await disable2Fa({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: disable2FaQueryKey(options)
    });
};

/**
 * Disable 2FA
 * Disable TOTP-based 2FA for the authenticated user.
 */
export const disable2FaMutation = (options?: Partial<Options<Disable2FaData>>): UseMutationOptions<Disable2FaResponse, Disable2FaError, Options<Disable2FaData>> => {
    const mutationOptions: UseMutationOptions<Disable2FaResponse, Disable2FaError, Options<Disable2FaData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await disable2Fa({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const enable2FaQueryKey = (options: Options<Enable2FaData>) => createQueryKey('enable2Fa', options);

/**
 * Enable 2FA
 * Enable TOTP-based 2FA for the authenticated user.
 */
export const enable2FaOptions = (options: Options<Enable2FaData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enable2Fa({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enable2FaQueryKey(options)
    });
};

/**
 * Enable 2FA
 * Enable TOTP-based 2FA for the authenticated user.
 */
export const enable2FaMutation = (options?: Partial<Options<Enable2FaData>>): UseMutationOptions<Enable2FaResponse, Enable2FaError, Options<Enable2FaData>> => {
    const mutationOptions: UseMutationOptions<Enable2FaResponse, Enable2FaError, Options<Enable2FaData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await enable2Fa({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const loginQueryKey = (options: Options<LoginData>) => createQueryKey('login', options);

/**
 * Login
 * Authenticate a user and establish a session. Provide TOTP code if 2FA is enabled.
 */
export const loginOptions = (options: Options<LoginData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await login({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: loginQueryKey(options)
    });
};

/**
 * Login
 * Authenticate a user and establish a session. Provide TOTP code if 2FA is enabled.
 */
export const loginMutation = (options?: Partial<Options<LoginData>>): UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> => {
    const mutationOptions: UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await login({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const logoutQueryKey = (options?: Options<LogoutData>) => createQueryKey('logout', options);

/**
 * Logout
 * Invalidate the current session and clear the auth cookie.
 */
export const logoutOptions = (options?: Options<LogoutData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await logout({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: logoutQueryKey(options)
    });
};

/**
 * Logout
 * Invalidate the current session and clear the auth cookie.
 */
export const logoutMutation = (options?: Partial<Options<LogoutData>>): UseMutationOptions<LogoutResponse, LogoutError, Options<LogoutData>> => {
    const mutationOptions: UseMutationOptions<LogoutResponse, LogoutError, Options<LogoutData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await logout({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const registerQueryKey = (options: Options<RegisterData>) => createQueryKey('register', options);

/**
 * Register a new user
 * Create a user account and start a session. Email verification is required.
 */
export const registerOptions = (options: Options<RegisterData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await register({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: registerQueryKey(options)
    });
};

/**
 * Register a new user
 * Create a user account and start a session. Email verification is required.
 */
export const registerMutation = (options?: Partial<Options<RegisterData>>): UseMutationOptions<RegisterResponse2, RegisterError, Options<RegisterData>> => {
    const mutationOptions: UseMutationOptions<RegisterResponse2, RegisterError, Options<RegisterData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await register({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const requestPasswordResetQueryKey = (options: Options<RequestPasswordResetData>) => createQueryKey('requestPasswordReset', options);

/**
 * Request password reset
 * Send a password reset email to the given address if it exists.
 */
export const requestPasswordResetOptions = (options: Options<RequestPasswordResetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await requestPasswordReset({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: requestPasswordResetQueryKey(options)
    });
};

/**
 * Request password reset
 * Send a password reset email to the given address if it exists.
 */
export const requestPasswordResetMutation = (options?: Partial<Options<RequestPasswordResetData>>): UseMutationOptions<RequestPasswordResetResponse, RequestPasswordResetError, Options<RequestPasswordResetData>> => {
    const mutationOptions: UseMutationOptions<RequestPasswordResetResponse, RequestPasswordResetError, Options<RequestPasswordResetData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await requestPasswordReset({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resendVerificationQueryKey = (options: Options<ResendVerificationData>) => createQueryKey('resendVerification', options);

/**
 * Resend verification email
 * Resend email verification code, with rate limiting.
 */
export const resendVerificationOptions = (options: Options<ResendVerificationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resendVerification({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resendVerificationQueryKey(options)
    });
};

/**
 * Resend verification email
 * Resend email verification code, with rate limiting.
 */
export const resendVerificationMutation = (options?: Partial<Options<ResendVerificationData>>): UseMutationOptions<ResendVerificationResponse, ResendVerificationError, Options<ResendVerificationData>> => {
    const mutationOptions: UseMutationOptions<ResendVerificationResponse, ResendVerificationError, Options<ResendVerificationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resendVerification({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resetPasswordQueryKey = (options: Options<ResetPasswordData>) => createQueryKey('resetPassword', options);

/**
 * Reset password
 * Reset the password using a token sent via email.
 */
export const resetPasswordOptions = (options: Options<ResetPasswordData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resetPassword({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resetPasswordQueryKey(options)
    });
};

/**
 * Reset password
 * Reset the password using a token sent via email.
 */
export const resetPasswordMutation = (options?: Partial<Options<ResetPasswordData>>): UseMutationOptions<ResetPasswordResponse, ResetPasswordError, Options<ResetPasswordData>> => {
    const mutationOptions: UseMutationOptions<ResetPasswordResponse, ResetPasswordError, Options<ResetPasswordData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resetPassword({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const setup2FaQueryKey = (options?: Options<Setup2FaData>) => createQueryKey('setup2Fa', options);

/**
 * Setup 2FA
 * Initiate time-based one-time password (TOTP) setup and return secret and backup codes.
 */
export const setup2FaOptions = (options?: Options<Setup2FaData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await setup2Fa({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: setup2FaQueryKey(options)
    });
};

/**
 * Setup 2FA
 * Initiate time-based one-time password (TOTP) setup and return secret and backup codes.
 */
export const setup2FaMutation = (options?: Partial<Options<Setup2FaData>>): UseMutationOptions<Setup2FaResponse2, Setup2FaError, Options<Setup2FaData>> => {
    const mutationOptions: UseMutationOptions<Setup2FaResponse2, Setup2FaError, Options<Setup2FaData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await setup2Fa({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const verifyEmailQueryKey = (options: Options<VerifyEmailData>) => createQueryKey('verifyEmail', options);

/**
 * Verify email
 * Verify the user's email address using a token.
 */
export const verifyEmailOptions = (options: Options<VerifyEmailData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await verifyEmail({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: verifyEmailQueryKey(options)
    });
};

/**
 * Verify email
 * Verify the user's email address using a token.
 */
export const verifyEmailMutation = (options?: Partial<Options<VerifyEmailData>>): UseMutationOptions<VerifyEmailResponse, VerifyEmailError, Options<VerifyEmailData>> => {
    const mutationOptions: UseMutationOptions<VerifyEmailResponse, VerifyEmailError, Options<VerifyEmailData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await verifyEmail({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createCheckoutQueryKey = (options: Options<CreateCheckoutData>) => createQueryKey('createCheckout', options);

/**
 * Create Paddle checkout
 * Creates a Paddle payment link for the given price. Optionally associates the link to a customer and organization. Use the returned URL to redirect the user to checkout.
 */
export const createCheckoutOptions = (options: Options<CreateCheckoutData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createCheckout({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createCheckoutQueryKey(options)
    });
};

/**
 * Create Paddle checkout
 * Creates a Paddle payment link for the given price. Optionally associates the link to a customer and organization. Use the returned URL to redirect the user to checkout.
 */
export const createCheckoutMutation = (options?: Partial<Options<CreateCheckoutData>>): UseMutationOptions<CreateCheckoutResponse2, DefaultError, Options<CreateCheckoutData>> => {
    const mutationOptions: UseMutationOptions<CreateCheckoutResponse2, DefaultError, Options<CreateCheckoutData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createCheckout({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createAdjustmentQueryKey = (options: Options<CreateAdjustmentData>) => createQueryKey('createAdjustment', options);

/**
 * Create invoice adjustment
 * Creates a credit or debit adjustment for the specified invoice.
 */
export const createAdjustmentOptions = (options: Options<CreateAdjustmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createAdjustment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createAdjustmentQueryKey(options)
    });
};

/**
 * Create invoice adjustment
 * Creates a credit or debit adjustment for the specified invoice.
 */
export const createAdjustmentMutation = (options?: Partial<Options<CreateAdjustmentData>>): UseMutationOptions<CreateAdjustmentResponse, DefaultError, Options<CreateAdjustmentData>> => {
    const mutationOptions: UseMutationOptions<CreateAdjustmentResponse, DefaultError, Options<CreateAdjustmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createAdjustment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const refundPaymentQueryKey = (options: Options<RefundPaymentData>) => createQueryKey('refundPayment', options);

/**
 * Refund a payment
 * Requests a refund for a given payment. Amount can be full or partial.
 */
export const refundPaymentOptions = (options: Options<RefundPaymentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await refundPayment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: refundPaymentQueryKey(options)
    });
};

/**
 * Refund a payment
 * Requests a refund for a given payment. Amount can be full or partial.
 */
export const refundPaymentMutation = (options?: Partial<Options<RefundPaymentData>>): UseMutationOptions<RefundPaymentResponse, DefaultError, Options<RefundPaymentData>> => {
    const mutationOptions: UseMutationOptions<RefundPaymentResponse, DefaultError, Options<RefundPaymentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await refundPayment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPublicConfigQueryKey = (options?: Options<GetPublicConfigData>) => createQueryKey('getPublicConfig', options);

/**
 * Public billing configuration
 * Returns Paddle client token and environment for Paddle.js initialization.
 */
export const getPublicConfigOptions = (options?: Options<GetPublicConfigData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPublicConfig({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPublicConfigQueryKey(options)
    });
};

export const getSubscriptionQueryKey = (options?: Options<GetSubscriptionData>) => createQueryKey('getSubscription', options);

/**
 * Get latest subscription snapshot for primary org
 * Returns a lightweight snapshot of the organization's latest subscription, or `status=none` if none exists.
 */
export const getSubscriptionOptions = (options?: Options<GetSubscriptionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSubscription({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSubscriptionQueryKey(options)
    });
};

export const listSubscriptionsQueryKey = (options?: Options<ListSubscriptionsData>) => createQueryKey('listSubscriptions', options);

/**
 * List subscriptions
 * Lists subscriptions for the primary organization. Filter by status and limit results.
 */
export const listSubscriptionsOptions = (options?: Options<ListSubscriptionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSubscriptions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSubscriptionsQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const listSubscriptionsInfiniteQueryKey = (options?: Options<ListSubscriptionsData>): QueryKey<Options<ListSubscriptionsData>> => createQueryKey('listSubscriptions', options, true);

/**
 * List subscriptions
 * Lists subscriptions for the primary organization. Filter by status and limit results.
 */
export const listSubscriptionsInfiniteOptions = (options?: Options<ListSubscriptionsData>) => {
    return infiniteQueryOptions<ListSubscriptionsResponse, DefaultError, InfiniteData<ListSubscriptionsResponse>, QueryKey<Options<ListSubscriptionsData>>, string | Pick<QueryKey<Options<ListSubscriptionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListSubscriptionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    cursor: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listSubscriptions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSubscriptionsInfiniteQueryKey(options)
    });
};

export const createSubscriptionQueryKey = (options: Options<CreateSubscriptionData>) => createQueryKey('createSubscription', options);

/**
 * Create subscription
 * Creates a subscription for the primary organization. Requires appropriate permissions.
 */
export const createSubscriptionOptions = (options: Options<CreateSubscriptionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createSubscription({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createSubscriptionQueryKey(options)
    });
};

/**
 * Create subscription
 * Creates a subscription for the primary organization. Requires appropriate permissions.
 */
export const createSubscriptionMutation = (options?: Partial<Options<CreateSubscriptionData>>): UseMutationOptions<unknown, DefaultError, Options<CreateSubscriptionData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CreateSubscriptionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createSubscription({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const changeSubscriptionQueryKey = (options: Options<ChangeSubscriptionData>) => createQueryKey('changeSubscription', options);

/**
 * Change subscription
 * Updates subscription quantity and/or price. Proration behavior can be specified.
 */
export const changeSubscriptionOptions = (options: Options<ChangeSubscriptionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await changeSubscription({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: changeSubscriptionQueryKey(options)
    });
};

/**
 * Change subscription
 * Updates subscription quantity and/or price. Proration behavior can be specified.
 */
export const changeSubscriptionMutation = (options?: Partial<Options<ChangeSubscriptionData>>): UseMutationOptions<unknown, DefaultError, Options<ChangeSubscriptionData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ChangeSubscriptionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await changeSubscription({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const cancelSubscriptionQueryKey = (options: Options<CancelSubscriptionData>) => createQueryKey('cancelSubscription', options);

/**
 * Cancel subscription
 * Cancels a subscription immediately or schedules cancellation at period end.
 */
export const cancelSubscriptionOptions = (options: Options<CancelSubscriptionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await cancelSubscription({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: cancelSubscriptionQueryKey(options)
    });
};

/**
 * Cancel subscription
 * Cancels a subscription immediately or schedules cancellation at period end.
 */
export const cancelSubscriptionMutation = (options?: Partial<Options<CancelSubscriptionData>>): UseMutationOptions<unknown, DefaultError, Options<CancelSubscriptionData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CancelSubscriptionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await cancelSubscription({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resumeSubscriptionQueryKey = (options: Options<ResumeSubscriptionData>) => createQueryKey('resumeSubscription', options);

/**
 * Resume subscription
 * Resumes a subscription that was scheduled to be canceled at period end.
 */
export const resumeSubscriptionOptions = (options: Options<ResumeSubscriptionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resumeSubscription({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resumeSubscriptionQueryKey(options)
    });
};

/**
 * Resume subscription
 * Resumes a subscription that was scheduled to be canceled at period end.
 */
export const resumeSubscriptionMutation = (options?: Partial<Options<ResumeSubscriptionData>>): UseMutationOptions<unknown, DefaultError, Options<ResumeSubscriptionData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ResumeSubscriptionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resumeSubscription({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const paddleWebhookQueryKey = (options?: Options<PaddleWebhookData>) => createQueryKey('paddleWebhook', options);

/**
 * Paddle webhook endpoint
 * Validates Paddle signature and processes billing events. This endpoint is intended to be called by Paddle.
 */
export const paddleWebhookOptions = (options?: Options<PaddleWebhookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await paddleWebhook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: paddleWebhookQueryKey(options)
    });
};

/**
 * Paddle webhook endpoint
 * Validates Paddle signature and processes billing events. This endpoint is intended to be called by Paddle.
 */
export const paddleWebhookMutation = (options?: Partial<Options<PaddleWebhookData>>): UseMutationOptions<unknown, DefaultError, Options<PaddleWebhookData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<PaddleWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await paddleWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const identifyUserQueryKey = (options: Options<IdentifyUserData>) => createQueryKey('identifyUser', options);

/**
 * Identify client user
 * Identify or create a client-side user by email or anonymous ID in a given org domain.
 */
export const identifyUserOptions = (options: Options<IdentifyUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await identifyUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: identifyUserQueryKey(options)
    });
};

/**
 * Identify client user
 * Identify or create a client-side user by email or anonymous ID in a given org domain.
 */
export const identifyUserMutation = (options?: Partial<Options<IdentifyUserData>>): UseMutationOptions<IdentifyUserResponse, DefaultError, Options<IdentifyUserData>> => {
    const mutationOptions: UseMutationOptions<IdentifyUserResponse, DefaultError, Options<IdentifyUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await identifyUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const sendMessageQueryKey = (options: Options<SendMessageData>) => createQueryKey('sendMessage', options);

/**
 * Submit client message
 * Submit a message from the client widget; creates a ticket and initial message.
 */
export const sendMessageOptions = (options: Options<SendMessageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await sendMessage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: sendMessageQueryKey(options)
    });
};

/**
 * Submit client message
 * Submit a message from the client widget; creates a ticket and initial message.
 */
export const sendMessageMutation = (options?: Partial<Options<SendMessageData>>): UseMutationOptions<SendMessageResponse, DefaultError, Options<SendMessageData>> => {
    const mutationOptions: UseMutationOptions<SendMessageResponse, DefaultError, Options<SendMessageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await sendMessage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTicketHistoryPublicQueryKey = (options: Options<GetTicketHistoryPublicData>) => createQueryKey('getTicketHistoryPublic', options);

/**
 * Get ticket history (public)
 * Get event history for a ticket visible to client users in the specified org domain.
 */
export const getTicketHistoryPublicOptions = (options: Options<GetTicketHistoryPublicData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTicketHistoryPublic({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTicketHistoryPublicQueryKey(options)
    });
};

export const getTicketMessagesPublicQueryKey = (options: Options<GetTicketMessagesPublicData>) => createQueryKey('getTicketMessagesPublic', options);

/**
 * Get ticket messages (public)
 * Get public messages for a ticket visible to client users in the specified org domain.
 */
export const getTicketMessagesPublicOptions = (options: Options<GetTicketMessagesPublicData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTicketMessagesPublic({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTicketMessagesPublicQueryKey(options)
    });
};

export const getUserTicketsQueryKey = (options: Options<GetUserTicketsData>) => createQueryKey('getUserTickets', options);

/**
 * List client tickets
 * List tickets created by the given client user in the specified org domain.
 */
export const getUserTicketsOptions = (options: Options<GetUserTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserTicketsQueryKey(options)
    });
};

export const getUserOrganizationsQueryKey = (options?: Options<GetUserOrganizationsData>) => createQueryKey('getUserOrganizations', options);

/**
 * List organizations
 * List organizations for the current user.
 */
export const getUserOrganizationsOptions = (options?: Options<GetUserOrganizationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserOrganizations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserOrganizationsQueryKey(options)
    });
};

export const createOrganizationQueryKey = (options: Options<CreateOrganizationData>) => createQueryKey('createOrganization', options);

/**
 * Create organization
 * Create a new organization and assign the creator as Admin.
 */
export const createOrganizationOptions = (options: Options<CreateOrganizationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createOrganization({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createOrganizationQueryKey(options)
    });
};

/**
 * Create organization
 * Create a new organization and assign the creator as Admin.
 */
export const createOrganizationMutation = (options?: Partial<Options<CreateOrganizationData>>): UseMutationOptions<CreateOrganizationResponse, DefaultError, Options<CreateOrganizationData>> => {
    const mutationOptions: UseMutationOptions<CreateOrganizationResponse, DefaultError, Options<CreateOrganizationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createOrganization({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findOrganizationsByEmailDomainQueryKey = (options: Options<FindOrganizationsByEmailDomainData>) => createQueryKey('findOrganizationsByEmailDomain', options);

/**
 * Find orgs by email domain
 * Find organizations that match the domain of an email address.
 */
export const findOrganizationsByEmailDomainOptions = (options: Options<FindOrganizationsByEmailDomainData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findOrganizationsByEmailDomain({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findOrganizationsByEmailDomainQueryKey(options)
    });
};

export const joinOrganizationQueryKey = (options: Options<JoinOrganizationData>) => createQueryKey('joinOrganization', options);

/**
 * Join organization by domain
 * Join an organization if email domain matches and setting allows.
 */
export const joinOrganizationOptions = (options: Options<JoinOrganizationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await joinOrganization({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: joinOrganizationQueryKey(options)
    });
};

/**
 * Join organization by domain
 * Join an organization if email domain matches and setting allows.
 */
export const joinOrganizationMutation = (options?: Partial<Options<JoinOrganizationData>>): UseMutationOptions<JoinOrganizationResponse, DefaultError, Options<JoinOrganizationData>> => {
    const mutationOptions: UseMutationOptions<JoinOrganizationResponse, DefaultError, Options<JoinOrganizationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await joinOrganization({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationQueryKey = (options: Options<GetOrganizationData>) => createQueryKey('getOrganization', options);

/**
 * Get organization
 * Get organization details by ID.
 */
export const getOrganizationOptions = (options: Options<GetOrganizationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrganization({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationQueryKey(options)
    });
};

export const acceptInvitationQueryKey = (options: Options<AcceptInvitationData>) => createQueryKey('acceptInvitation', options);

/**
 * Accept invitation
 * Accept a pending organization invitation.
 */
export const acceptInvitationOptions = (options: Options<AcceptInvitationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await acceptInvitation({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: acceptInvitationQueryKey(options)
    });
};

/**
 * Accept invitation
 * Accept a pending organization invitation.
 */
export const acceptInvitationMutation = (options?: Partial<Options<AcceptInvitationData>>): UseMutationOptions<AcceptInvitationResponse, DefaultError, Options<AcceptInvitationData>> => {
    const mutationOptions: UseMutationOptions<AcceptInvitationResponse, DefaultError, Options<AcceptInvitationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await acceptInvitation({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listEventsQueryKey = (options: Options<ListEventsData>) => createQueryKey('listEvents', options);

export const listEventsOptions = (options: Options<ListEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listEventsQueryKey(options)
    });
};

export const listEventsInfiniteQueryKey = (options: Options<ListEventsData>): QueryKey<Options<ListEventsData>> => createQueryKey('listEvents', options, true);

export const listEventsInfiniteOptions = (options: Options<ListEventsData>) => {
    return infiniteQueryOptions<ListEventsResponse, ListEventsError, InfiniteData<ListEventsResponse>, QueryKey<Options<ListEventsData>>, number | Pick<QueryKey<Options<ListEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listEvents({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listEventsInfiniteQueryKey(options)
    });
};

export const createEventQueryKey = (options: Options<CreateEventData>) => createQueryKey('createEvent', options);

/**
 * Create audit event
 * Creates a custom event in the audit trail.
 */
export const createEventOptions = (options: Options<CreateEventData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createEvent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createEventQueryKey(options)
    });
};

/**
 * Create audit event
 * Creates a custom event in the audit trail.
 */
export const createEventMutation = (options?: Partial<Options<CreateEventData>>): UseMutationOptions<CreateEventResponse, CreateEventError, Options<CreateEventData>> => {
    const mutationOptions: UseMutationOptions<CreateEventResponse, CreateEventError, Options<CreateEventData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createEvent({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const exportEventsQueryKey = (options: Options<ExportEventsData>) => createQueryKey('exportEvents', options);

export const exportEventsOptions = (options: Options<ExportEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await exportEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: exportEventsQueryKey(options)
    });
};

export const getEventStatsQueryKey = (options: Options<GetEventStatsData>) => createQueryKey('getEventStats', options);

export const getEventStatsOptions = (options: Options<GetEventStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEventStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEventStatsQueryKey(options)
    });
};

export const streamEventsQueryKey = (options: Options<StreamEventsData>) => createQueryKey('streamEvents', options);

export const streamEventsOptions = (options: Options<StreamEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await streamEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: streamEventsQueryKey(options)
    });
};

export const wsEventsQueryKey = (options: Options<WsEventsData>) => createQueryKey('wsEvents', options);

/**
 * WebSocket events stream
 * Upgrades to WebSocket for realtime org events.
 *
 * Auth: This endpoint does not use bearerAuth; authenticate in-band by sending {op:'auth', token} with the short-lived JWT obtained from /events/ws/init.
 *
 * Usage:
 *
 * 1) Connect WS to this endpoint.
 * 2) Server hello: {"op":"hello","conn_id":"...","heartbeat_ms":30000,"max_backlog":500}.
 * 3) Send auth: {"op":"auth","token":"<jwt>"}.
 * 4) On {"op":"authok"}, subscribe to topics and receive events.
 * 5) Before expiry you'll receive {"op":"authexpiring"}; fetch a new token from /events/ws/init and send a new auth without reconnecting.
 *
 * Client envelopes (JSON): subscribe/unsubscribe/resume/ping as documented above.
 * Server envelopes (JSON): hello/event/pong/error/authok/authexpiring.
 */
export const wsEventsOptions = (options: Options<WsEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await wsEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: wsEventsQueryKey(options)
    });
};

export const wsAuthQueryKey = (options: Options<WsAuthData>) => createQueryKey('wsAuth', options);

/**
 * Get WebSocket URL and token
 * Returns a ws(s) URL and a short-lived JWT for establishing the WS connection. The server will send an `error` event with code `TOKEN_EXPIRING` ~60s before expiry to prompt re-auth.
 */
export const wsAuthOptions = (options: Options<WsAuthData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await wsAuth({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: wsAuthQueryKey(options)
    });
};

export const getEventQueryKey = (options: Options<GetEventData>) => createQueryKey('getEvent', options);

export const getEventOptions = (options: Options<GetEventData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEvent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEventQueryKey(options)
    });
};

export const inviteUserQueryKey = (options: Options<InviteUserData>) => createQueryKey('inviteUser', options);

/**
 * Invite user
 * Invite a user to join the organization.
 */
export const inviteUserOptions = (options: Options<InviteUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await inviteUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: inviteUserQueryKey(options)
    });
};

/**
 * Invite user
 * Invite a user to join the organization.
 */
export const inviteUserMutation = (options?: Partial<Options<InviteUserData>>): UseMutationOptions<InviteUserResponse, DefaultError, Options<InviteUserData>> => {
    const mutationOptions: UseMutationOptions<InviteUserResponse, DefaultError, Options<InviteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await inviteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMembersQueryKey = (options: Options<GetMembersData>) => createQueryKey('getMembers', options);

/**
 * List members
 * List organization members and their statuses.
 */
export const getMembersOptions = (options: Options<GetMembersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMembers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMembersQueryKey(options)
    });
};

/**
 * Remove member
 * Remove a member from the organization.
 */
export const removeMemberMutation = (options?: Partial<Options<RemoveMemberData>>): UseMutationOptions<RemoveMemberResponse, DefaultError, Options<RemoveMemberData>> => {
    const mutationOptions: UseMutationOptions<RemoveMemberResponse, DefaultError, Options<RemoveMemberData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeMember({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update membership
 * Update membership status (active, invited, requested, suspended).
 */
export const updateMembershipMutation = (options?: Partial<Options<UpdateMembershipData>>): UseMutationOptions<UpdateMembershipResponse, DefaultError, Options<UpdateMembershipData>> => {
    const mutationOptions: UseMutationOptions<UpdateMembershipResponse, DefaultError, Options<UpdateMembershipData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateMembership({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteMessageMutation = (options?: Partial<Options<DeleteMessageData>>): UseMutationOptions<DeleteMessageResponse, DeleteMessageError, Options<DeleteMessageData>> => {
    const mutationOptions: UseMutationOptions<DeleteMessageResponse, DeleteMessageError, Options<DeleteMessageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteMessage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMessageQueryKey = (options: Options<GetMessageData>) => createQueryKey('getMessage', options);

export const getMessageOptions = (options: Options<GetMessageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMessage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMessageQueryKey(options)
    });
};

export const getEffectivePermissionsQueryKey = (options: Options<GetEffectivePermissionsData>) => createQueryKey('getEffectivePermissions', options);

/**
 * Get effective permissions
 * Compute effective permission bitmask for the current user in the organization.
 */
export const getEffectivePermissionsOptions = (options: Options<GetEffectivePermissionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEffectivePermissions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEffectivePermissionsQueryKey(options)
    });
};

export const listAgentsQueryKey = (options: Options<ListAgentsData>) => createQueryKey('listAgents', options);

/**
 * List online agents
 * List agents with recent presence heartbeats and their current ticket context.
 */
export const listAgentsOptions = (options: Options<ListAgentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listAgents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listAgentsQueryKey(options)
    });
};

export const heartbeatQueryKey = (options: Options<HeartbeatData>) => createQueryKey('heartbeat', options);

/**
 * Send agent presence heartbeat
 * Send a presence heartbeat to update agent status and current/editing ticket context.
 */
export const heartbeatOptions = (options: Options<HeartbeatData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await heartbeat({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: heartbeatQueryKey(options)
    });
};

/**
 * Send agent presence heartbeat
 * Send a presence heartbeat to update agent status and current/editing ticket context.
 */
export const heartbeatMutation = (options?: Partial<Options<HeartbeatData>>): UseMutationOptions<HeartbeatResponse, DefaultError, Options<HeartbeatData>> => {
    const mutationOptions: UseMutationOptions<HeartbeatResponse, DefaultError, Options<HeartbeatData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await heartbeat({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listRolesQueryKey = (options: Options<ListRolesData>) => createQueryKey('listRoles', options);

/**
 * List roles
 * List roles for the organization ordered by position.
 */
export const listRolesOptions = (options: Options<ListRolesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listRoles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listRolesQueryKey(options)
    });
};

export const createRoleQueryKey = (options: Options<CreateRoleData>) => createQueryKey('createRole', options);

/**
 * Create role
 * Create a new role with a permission bitmask and display settings.
 */
export const createRoleOptions = (options: Options<CreateRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createRoleQueryKey(options)
    });
};

/**
 * Create role
 * Create a new role with a permission bitmask and display settings.
 */
export const createRoleMutation = (options?: Partial<Options<CreateRoleData>>): UseMutationOptions<CreateRoleResponse, DefaultError, Options<CreateRoleData>> => {
    const mutationOptions: UseMutationOptions<CreateRoleResponse, DefaultError, Options<CreateRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete role
 * Delete a role by ID.
 */
export const deleteRoleMutation = (options?: Partial<Options<DeleteRoleData>>): UseMutationOptions<DeleteRoleResponse, DefaultError, Options<DeleteRoleData>> => {
    const mutationOptions: UseMutationOptions<DeleteRoleResponse, DefaultError, Options<DeleteRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRoleQueryKey = (options: Options<GetRoleData>) => createQueryKey('getRole', options);

/**
 * Get role
 * Retrieve a role by ID.
 */
export const getRoleOptions = (options: Options<GetRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRoleQueryKey(options)
    });
};

/**
 * Update role
 * Update role fields like name, color, position, and permissions.
 */
export const updateRoleMutation = (options?: Partial<Options<UpdateRoleData>>): UseMutationOptions<UpdateRoleResponse, DefaultError, Options<UpdateRoleData>> => {
    const mutationOptions: UseMutationOptions<UpdateRoleResponse, DefaultError, Options<UpdateRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const assignRoleQueryKey = (options: Options<AssignRoleData>) => createQueryKey('assignRole', options);

/**
 * Assign role
 * Assign a role to a user.
 */
export const assignRoleOptions = (options: Options<AssignRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignRoleQueryKey(options)
    });
};

/**
 * Assign role
 * Assign a role to a user.
 */
export const assignRoleMutation = (options?: Partial<Options<AssignRoleData>>): UseMutationOptions<AssignRoleResponse, DefaultError, Options<AssignRoleData>> => {
    const mutationOptions: UseMutationOptions<AssignRoleResponse, DefaultError, Options<AssignRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await assignRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const revokeRoleQueryKey = (options: Options<RevokeRoleData>) => createQueryKey('revokeRole', options);

/**
 * Revoke role
 * Revoke a role from a user.
 */
export const revokeRoleOptions = (options: Options<RevokeRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await revokeRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: revokeRoleQueryKey(options)
    });
};

/**
 * Revoke role
 * Revoke a role from a user.
 */
export const revokeRoleMutation = (options?: Partial<Options<RevokeRoleData>>): UseMutationOptions<RevokeRoleResponse, DefaultError, Options<RevokeRoleData>> => {
    const mutationOptions: UseMutationOptions<RevokeRoleResponse, DefaultError, Options<RevokeRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await revokeRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllOrganizationSettingsQueryKey = (options: Options<GetAllOrganizationSettingsData>) => createQueryKey('getAllOrganizationSettings', options);

/**
 * List settings
 * List all organization settings.
 */
export const getAllOrganizationSettingsOptions = (options: Options<GetAllOrganizationSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllOrganizationSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllOrganizationSettingsQueryKey(options)
    });
};

export const setOrganizationSettingQueryKey = (options: Options<SetOrganizationSettingData>) => createQueryKey('setOrganizationSetting', options);

/**
 * Set organization setting
 * Create or update an organization setting.
 */
export const setOrganizationSettingOptions = (options: Options<SetOrganizationSettingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await setOrganizationSetting({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: setOrganizationSettingQueryKey(options)
    });
};

/**
 * Set organization setting
 * Create or update an organization setting.
 */
export const setOrganizationSettingMutation = (options?: Partial<Options<SetOrganizationSettingData>>): UseMutationOptions<SetOrganizationSettingResponse, DefaultError, Options<SetOrganizationSettingData>> => {
    const mutationOptions: UseMutationOptions<SetOrganizationSettingResponse, DefaultError, Options<SetOrganizationSettingData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await setOrganizationSetting({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const applyDataRetentionQueryKey = (options: Options<ApplyDataRetentionData>) => createQueryKey('applyDataRetention', options);

/**
 * Apply data retention
 * Run data retention worker once for the organization.
 */
export const applyDataRetentionOptions = (options: Options<ApplyDataRetentionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await applyDataRetention({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: applyDataRetentionQueryKey(options)
    });
};

/**
 * Apply data retention
 * Run data retention worker once for the organization.
 */
export const applyDataRetentionMutation = (options?: Partial<Options<ApplyDataRetentionData>>): UseMutationOptions<ApplyDataRetentionResponse, DefaultError, Options<ApplyDataRetentionData>> => {
    const mutationOptions: UseMutationOptions<ApplyDataRetentionResponse, DefaultError, Options<ApplyDataRetentionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await applyDataRetention({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrgEffectiveSettingsQueryKey = (options: Options<GetOrgEffectiveSettingsData>) => createQueryKey('getOrgEffectiveSettings', options);

/**
 * Effective org settings
 * Get effective organization settings (defaults plus overrides).
 */
export const getOrgEffectiveSettingsOptions = (options: Options<GetOrgEffectiveSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrgEffectiveSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrgEffectiveSettingsQueryKey(options)
    });
};

/**
 * Delete setting
 * Delete an organization setting.
 */
export const deleteOrganizationSettingMutation = (options?: Partial<Options<DeleteOrganizationSettingData>>): UseMutationOptions<DeleteOrganizationSettingResponse, DefaultError, Options<DeleteOrganizationSettingData>> => {
    const mutationOptions: UseMutationOptions<DeleteOrganizationSettingResponse, DefaultError, Options<DeleteOrganizationSettingData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteOrganizationSetting({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationSettingQueryKey = (options: Options<GetOrganizationSettingData>) => createQueryKey('getOrganizationSetting', options);

/**
 * Get setting
 * Get a single organization setting value.
 */
export const getOrganizationSettingOptions = (options: Options<GetOrganizationSettingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrganizationSetting({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationSettingQueryKey(options)
    });
};

export const checkBreachesQueryKey = (options: Options<CheckBreachesData>) => createQueryKey('checkBreaches', options);

/**
 * Check SLA breaches
 * Evaluate tickets against SLA policies and mark breaches.
 */
export const checkBreachesOptions = (options: Options<CheckBreachesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await checkBreaches({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: checkBreachesQueryKey(options)
    });
};

/**
 * Check SLA breaches
 * Evaluate tickets against SLA policies and mark breaches.
 */
export const checkBreachesMutation = (options?: Partial<Options<CheckBreachesData>>): UseMutationOptions<CheckBreachesResponse, DefaultError, Options<CheckBreachesData>> => {
    const mutationOptions: UseMutationOptions<CheckBreachesResponse, DefaultError, Options<CheckBreachesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await checkBreaches({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const countdownSseQueryKey = (options: Options<CountdownSseData>) => createQueryKey('countdownSse', options);

/**
 * SLA countdown stream
 * Server-Sent Events (SSE) stream of remaining time for first response and resolution.
 */
export const countdownSseOptions = (options: Options<CountdownSseData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await countdownSse({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: countdownSseQueryKey(options)
    });
};

export const listPoliciesQueryKey = (options: Options<ListPoliciesData>) => createQueryKey('listPolicies', options);

/**
 * List SLA policies
 * List SLA policies for an organization.
 */
export const listPoliciesOptions = (options: Options<ListPoliciesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listPolicies({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listPoliciesQueryKey(options)
    });
};

export const createPolicyQueryKey = (options: Options<CreatePolicyData>) => createQueryKey('createPolicy', options);

/**
 * Create SLA policy
 * Create an SLA policy with conditions and targets.
 */
export const createPolicyOptions = (options: Options<CreatePolicyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createPolicy({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createPolicyQueryKey(options)
    });
};

/**
 * Create SLA policy
 * Create an SLA policy with conditions and targets.
 */
export const createPolicyMutation = (options?: Partial<Options<CreatePolicyData>>): UseMutationOptions<CreatePolicyResponse, DefaultError, Options<CreatePolicyData>> => {
    const mutationOptions: UseMutationOptions<CreatePolicyResponse, DefaultError, Options<CreatePolicyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createPolicy({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update SLA policy
 * Update SLA policy fields such as targets or activation.
 */
export const updatePolicyMutation = (options?: Partial<Options<UpdatePolicyData>>): UseMutationOptions<UpdatePolicyResponse, DefaultError, Options<UpdatePolicyData>> => {
    const mutationOptions: UseMutationOptions<UpdatePolicyResponse, DefaultError, Options<UpdatePolicyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updatePolicy({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const syncOpsQueryKey = (options: Options<SyncOpsData>) => createQueryKey('syncOps', options);

/**
 * Apply sync operations (tickets)
 * Batch apply sync operations with optimistic concurrency. Currently supports entity=ticket with upsert of core fields.
 */
export const syncOpsOptions = (options: Options<SyncOpsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await syncOps({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: syncOpsQueryKey(options)
    });
};

/**
 * Apply sync operations (tickets)
 * Batch apply sync operations with optimistic concurrency. Currently supports entity=ticket with upsert of core fields.
 */
export const syncOpsMutation = (options?: Partial<Options<SyncOpsData>>): UseMutationOptions<SyncOpsResponse2, DefaultError, Options<SyncOpsData>> => {
    const mutationOptions: UseMutationOptions<SyncOpsResponse2, DefaultError, Options<SyncOpsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await syncOps({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const syncSnapshotQueryKey = (options: Options<SyncSnapshotData>) => createQueryKey('syncSnapshot', options);

/**
 * Sync snapshot
 * Returns a compact snapshot for requested types and the current head sequence.
 */
export const syncSnapshotOptions = (options: Options<SyncSnapshotData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await syncSnapshot({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: syncSnapshotQueryKey(options)
    });
};

export const listTagsQueryKey = (options: Options<ListTagsData>) => createQueryKey('listTags', options);

/**
 * List tags
 * List tags for the organization with pagination.
 */
export const listTagsOptions = (options: Options<ListTagsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTags({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTagsQueryKey(options)
    });
};

export const listTagsInfiniteQueryKey = (options: Options<ListTagsData>): QueryKey<Options<ListTagsData>> => createQueryKey('listTags', options, true);

/**
 * List tags
 * List tags for the organization with pagination.
 */
export const listTagsInfiniteOptions = (options: Options<ListTagsData>) => {
    return infiniteQueryOptions<ListTagsResponse, DefaultError, InfiniteData<ListTagsResponse>, QueryKey<Options<ListTagsData>>, number | Pick<QueryKey<Options<ListTagsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListTagsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listTags({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTagsInfiniteQueryKey(options)
    });
};

export const createTagQueryKey = (options: Options<CreateTagData>) => createQueryKey('createTag', options);

/**
 * Create a tag
 * Create a new tag within the organization. Requires MANAGE_TAGS.
 */
export const createTagOptions = (options: Options<CreateTagData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createTag({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createTagQueryKey(options)
    });
};

/**
 * Create a tag
 * Create a new tag within the organization. Requires MANAGE_TAGS.
 */
export const createTagMutation = (options?: Partial<Options<CreateTagData>>): UseMutationOptions<CreateTagResponse, DefaultError, Options<CreateTagData>> => {
    const mutationOptions: UseMutationOptions<CreateTagResponse, DefaultError, Options<CreateTagData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createTag({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPopularTagsQueryKey = (options: Options<GetPopularTagsData>) => createQueryKey('getPopularTags', options);

/**
 * Popular tags
 * List the most-used tags in the organization.
 */
export const getPopularTagsOptions = (options: Options<GetPopularTagsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPopularTags({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPopularTagsQueryKey(options)
    });
};

/**
 * Delete a tag
 * Delete a tag and remove its associations. Requires MANAGE_TAGS.
 */
export const deleteTagMutation = (options?: Partial<Options<DeleteTagData>>): UseMutationOptions<DeleteTagResponse, DefaultError, Options<DeleteTagData>> => {
    const mutationOptions: UseMutationOptions<DeleteTagResponse, DefaultError, Options<DeleteTagData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteTag({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTagQueryKey = (options: Options<GetTagData>) => createQueryKey('getTag', options);

/**
 * Get a tag
 * Retrieve a tag by ID including computed ticket count.
 */
export const getTagOptions = (options: Options<GetTagData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTag({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagQueryKey(options)
    });
};

/**
 * Update a tag
 * Update tag name or color. Requires MANAGE_TAGS.
 */
export const updateTagMutation = (options?: Partial<Options<UpdateTagData>>): UseMutationOptions<UpdateTagResponse, DefaultError, Options<UpdateTagData>> => {
    const mutationOptions: UseMutationOptions<UpdateTagResponse, DefaultError, Options<UpdateTagData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTag({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTagWithTicketsQueryKey = (options: Options<GetTagWithTicketsData>) => createQueryKey('getTagWithTickets', options);

/**
 * Get tag with tickets
 * Get a tag and a paginated list of associated tickets.
 */
export const getTagWithTicketsOptions = (options: Options<GetTagWithTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTagWithTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagWithTicketsQueryKey(options)
    });
};

export const getTagWithTicketsInfiniteQueryKey = (options: Options<GetTagWithTicketsData>): QueryKey<Options<GetTagWithTicketsData>> => createQueryKey('getTagWithTickets', options, true);

/**
 * Get tag with tickets
 * Get a tag and a paginated list of associated tickets.
 */
export const getTagWithTicketsInfiniteOptions = (options: Options<GetTagWithTicketsData>) => {
    return infiniteQueryOptions<GetTagWithTicketsResponse, DefaultError, InfiniteData<GetTagWithTicketsResponse>, QueryKey<Options<GetTagWithTicketsData>>, number | Pick<QueryKey<Options<GetTagWithTicketsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetTagWithTicketsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getTagWithTickets({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagWithTicketsInfiniteQueryKey(options)
    });
};

export const listTeamsQueryKey = (options: Options<ListTeamsData>) => createQueryKey('listTeams', options);

/**
 * List teams
 * List teams in the organization.
 */
export const listTeamsOptions = (options: Options<ListTeamsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTeams({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTeamsQueryKey(options)
    });
};

export const createTeamQueryKey = (options: Options<CreateTeamData>) => createQueryKey('createTeam', options);

/**
 * Create team
 * Create a team within the organization.
 */
export const createTeamOptions = (options: Options<CreateTeamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createTeam({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createTeamQueryKey(options)
    });
};

/**
 * Create team
 * Create a team within the organization.
 */
export const createTeamMutation = (options?: Partial<Options<CreateTeamData>>): UseMutationOptions<CreateTeamResponse, DefaultError, Options<CreateTeamData>> => {
    const mutationOptions: UseMutationOptions<CreateTeamResponse, DefaultError, Options<CreateTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update team
 * Update team name and description.
 */
export const updateTeamMutation = (options?: Partial<Options<UpdateTeamData>>): UseMutationOptions<UpdateTeamResponse, DefaultError, Options<UpdateTeamData>> => {
    const mutationOptions: UseMutationOptions<UpdateTeamResponse, DefaultError, Options<UpdateTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listMembersQueryKey = (options: Options<ListMembersData>) => createQueryKey('listMembers', options);

/**
 * List team members
 * List members in a team.
 */
export const listMembersOptions = (options: Options<ListMembersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listMembers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMembersQueryKey(options)
    });
};

export const addMemberQueryKey = (options: Options<AddMemberData>) => createQueryKey('addMember', options);

/**
 * Add team member
 * Add a user to a team with a role.
 */
export const addMemberOptions = (options: Options<AddMemberData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addMember({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addMemberQueryKey(options)
    });
};

/**
 * Add team member
 * Add a user to a team with a role.
 */
export const addMemberMutation = (options?: Partial<Options<AddMemberData>>): UseMutationOptions<AddMemberResponse, DefaultError, Options<AddMemberData>> => {
    const mutationOptions: UseMutationOptions<AddMemberResponse, DefaultError, Options<AddMemberData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addMember({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove team member
 * Remove a user from a team.
 */
export const removeMember2Mutation = (options?: Partial<Options<RemoveMember2Data>>): UseMutationOptions<RemoveMember2Response, DefaultError, Options<RemoveMember2Data>> => {
    const mutationOptions: UseMutationOptions<RemoveMember2Response, DefaultError, Options<RemoveMember2Data>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeMember2({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTicketsQueryKey = (options: Options<ListTicketsData>) => createQueryKey('listTickets', options);

/**
 * List tickets with filtering
 * Retrieves a paginated list of tickets with optional filtering by status, priority, assignment, creator, and tags. Results are ordered by creation date (newest first).
 */
export const listTicketsOptions = (options: Options<ListTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTicketsQueryKey(options)
    });
};

export const listTicketsInfiniteQueryKey = (options: Options<ListTicketsData>): QueryKey<Options<ListTicketsData>> => createQueryKey('listTickets', options, true);

/**
 * List tickets with filtering
 * Retrieves a paginated list of tickets with optional filtering by status, priority, assignment, creator, and tags. Results are ordered by creation date (newest first).
 */
export const listTicketsInfiniteOptions = (options: Options<ListTicketsData>) => {
    return infiniteQueryOptions<ListTicketsResponse, ListTicketsError, InfiniteData<ListTicketsResponse>, QueryKey<Options<ListTicketsData>>, number | Pick<QueryKey<Options<ListTicketsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListTicketsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listTickets({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTicketsInfiniteQueryKey(options)
    });
};

export const createTicketQueryKey = (options: Options<CreateTicketData>) => createQueryKey('createTicket', options);

/**
 * Create a new support ticket
 * Creates a new support ticket in the specified organization. The ticket will be assigned to the authenticated user as the creator and can optionally be assigned to another team member.
 */
export const createTicketOptions = (options: Options<CreateTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createTicketQueryKey(options)
    });
};

/**
 * Create a new support ticket
 * Creates a new support ticket in the specified organization. The ticket will be assigned to the authenticated user as the creator and can optionally be assigned to another team member.
 */
export const createTicketMutation = (options?: Partial<Options<CreateTicketData>>): UseMutationOptions<CreateTicketResponse, CreateTicketError, Options<CreateTicketData>> => {
    const mutationOptions: UseMutationOptions<CreateTicketResponse, CreateTicketError, Options<CreateTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkUpdateTicketsQueryKey = (options: Options<BulkUpdateTicketsData>) => createQueryKey('bulkUpdateTickets', options);

/**
 * Bulk update tickets
 */
export const bulkUpdateTicketsOptions = (options: Options<BulkUpdateTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await bulkUpdateTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: bulkUpdateTicketsQueryKey(options)
    });
};

/**
 * Bulk update tickets
 */
export const bulkUpdateTicketsMutation = (options?: Partial<Options<BulkUpdateTicketsData>>): UseMutationOptions<unknown, DefaultError, Options<BulkUpdateTicketsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<BulkUpdateTicketsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkUpdateTickets({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const mergeTicketsQueryKey = (options: Options<MergeTicketsData>) => createQueryKey('mergeTickets', options);

/**
 * Merge two tickets
 */
export const mergeTicketsOptions = (options: Options<MergeTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await mergeTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: mergeTicketsQueryKey(options)
    });
};

/**
 * Merge two tickets
 */
export const mergeTicketsMutation = (options?: Partial<Options<MergeTicketsData>>): UseMutationOptions<unknown, DefaultError, Options<MergeTicketsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<MergeTicketsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await mergeTickets({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const splitTicketQueryKey = (options: Options<SplitTicketData>) => createQueryKey('splitTicket', options);

/**
 * Split a ticket's selected messages into a new ticket
 */
export const splitTicketOptions = (options: Options<SplitTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await splitTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: splitTicketQueryKey(options)
    });
};

/**
 * Split a ticket's selected messages into a new ticket
 */
export const splitTicketMutation = (options?: Partial<Options<SplitTicketData>>): UseMutationOptions<SplitTicketResponse, DefaultError, Options<SplitTicketData>> => {
    const mutationOptions: UseMutationOptions<SplitTicketResponse, DefaultError, Options<SplitTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await splitTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listSavedViewsQueryKey = (options: Options<ListSavedViewsData>) => createQueryKey('listSavedViews', options);

/**
 * List saved views
 */
export const listSavedViewsOptions = (options: Options<ListSavedViewsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSavedViews({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSavedViewsQueryKey(options)
    });
};

export const createSavedViewQueryKey = (options: Options<CreateSavedViewData>) => createQueryKey('createSavedView', options);

/**
 * Create a saved view
 */
export const createSavedViewOptions = (options: Options<CreateSavedViewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createSavedView({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createSavedViewQueryKey(options)
    });
};

/**
 * Create a saved view
 */
export const createSavedViewMutation = (options?: Partial<Options<CreateSavedViewData>>): UseMutationOptions<CreateSavedViewResponse, DefaultError, Options<CreateSavedViewData>> => {
    const mutationOptions: UseMutationOptions<CreateSavedViewResponse, DefaultError, Options<CreateSavedViewData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createSavedView({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteTicketMutation = (options?: Partial<Options<DeleteTicketData>>): UseMutationOptions<DeleteTicketResponse, DeleteTicketError, Options<DeleteTicketData>> => {
    const mutationOptions: UseMutationOptions<DeleteTicketResponse, DeleteTicketError, Options<DeleteTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTicketQueryKey = (options: Options<GetTicketData>) => createQueryKey('getTicket', options);

/**
 * Get ticket details
 * Retrieves detailed information about a specific ticket including its current status, assignment, tags, and metadata.
 */
export const getTicketOptions = (options: Options<GetTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTicketQueryKey(options)
    });
};

export const updateTicketMutation = (options?: Partial<Options<UpdateTicketData>>): UseMutationOptions<UpdateTicketResponse, UpdateTicketError, Options<UpdateTicketData>> => {
    const mutationOptions: UseMutationOptions<UpdateTicketResponse, UpdateTicketError, Options<UpdateTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const assignTicketTeamQueryKey = (options: Options<AssignTicketTeamData>) => createQueryKey('assignTicketTeam', options);

export const assignTicketTeamOptions = (options: Options<AssignTicketTeamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignTicketTeam({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignTicketTeamQueryKey(options)
    });
};

export const assignTicketTeamMutation = (options?: Partial<Options<AssignTicketTeamData>>): UseMutationOptions<AssignTicketTeamResponse, AssignTicketTeamError, Options<AssignTicketTeamData>> => {
    const mutationOptions: UseMutationOptions<AssignTicketTeamResponse, AssignTicketTeamError, Options<AssignTicketTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await assignTicketTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const clearTicketTeamAssignmentMutation = (options?: Partial<Options<ClearTicketTeamAssignmentData>>): UseMutationOptions<ClearTicketTeamAssignmentResponse, DefaultError, Options<ClearTicketTeamAssignmentData>> => {
    const mutationOptions: UseMutationOptions<ClearTicketTeamAssignmentResponse, DefaultError, Options<ClearTicketTeamAssignmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await clearTicketTeamAssignment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTicketTeamAssignmentQueryKey = (options: Options<GetTicketTeamAssignmentData>) => createQueryKey('getTicketTeamAssignment', options);

export const getTicketTeamAssignmentOptions = (options: Options<GetTicketTeamAssignmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTicketTeamAssignment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTicketTeamAssignmentQueryKey(options)
    });
};

/**
 * Delete current user's draft for a ticket
 */
export const deleteDraftMutation = (options?: Partial<Options<DeleteDraftData>>): UseMutationOptions<DeleteDraftResponse, DefaultError, Options<DeleteDraftData>> => {
    const mutationOptions: UseMutationOptions<DeleteDraftResponse, DefaultError, Options<DeleteDraftData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteDraft({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDraftQueryKey = (options: Options<GetDraftData>) => createQueryKey('getDraft', options);

/**
 * Get current user's draft for a ticket
 */
export const getDraftOptions = (options: Options<GetDraftData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDraft({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDraftQueryKey(options)
    });
};

export const upsertDraftQueryKey = (options: Options<UpsertDraftData>) => createQueryKey('upsertDraft', options);

/**
 * Create or update a draft for a ticket
 */
export const upsertDraftOptions = (options: Options<UpsertDraftData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await upsertDraft({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: upsertDraftQueryKey(options)
    });
};

/**
 * Create or update a draft for a ticket
 */
export const upsertDraftMutation = (options?: Partial<Options<UpsertDraftData>>): UseMutationOptions<UpsertDraftResponse, DefaultError, Options<UpsertDraftData>> => {
    const mutationOptions: UseMutationOptions<UpsertDraftResponse, DefaultError, Options<UpsertDraftData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await upsertDraft({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTicketHistoryQueryKey = (options: Options<GetTicketHistoryData>) => createQueryKey('getTicketHistory', options);

/**
 * Get ticket history
 * Requires permission: VIEW_ALL_TICKETS
 */
export const getTicketHistoryOptions = (options: Options<GetTicketHistoryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTicketHistory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTicketHistoryQueryKey(options)
    });
};

export const releaseTicketLockMutation = (options?: Partial<Options<ReleaseTicketLockData>>): UseMutationOptions<ReleaseTicketLockResponse, DefaultError, Options<ReleaseTicketLockData>> => {
    const mutationOptions: UseMutationOptions<ReleaseTicketLockResponse, DefaultError, Options<ReleaseTicketLockData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await releaseTicketLock({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lockTicketQueryKey = (options: Options<LockTicketData>) => createQueryKey('lockTicket', options);

export const lockTicketOptions = (options: Options<LockTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lockTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lockTicketQueryKey(options)
    });
};

export const lockTicketMutation = (options?: Partial<Options<LockTicketData>>): UseMutationOptions<unknown, DefaultError, Options<LockTicketData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<LockTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lockTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const takeoverTicketLockQueryKey = (options: Options<TakeoverTicketLockData>) => createQueryKey('takeoverTicketLock', options);

export const takeoverTicketLockOptions = (options: Options<TakeoverTicketLockData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await takeoverTicketLock({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: takeoverTicketLockQueryKey(options)
    });
};

export const takeoverTicketLockMutation = (options?: Partial<Options<TakeoverTicketLockData>>): UseMutationOptions<unknown, DefaultError, Options<TakeoverTicketLockData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<TakeoverTicketLockData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await takeoverTicketLock({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTicketMessagesQueryKey = (options: Options<ListTicketMessagesData>) => createQueryKey('listTicketMessages', options);

export const listTicketMessagesOptions = (options: Options<ListTicketMessagesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTicketMessages({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTicketMessagesQueryKey(options)
    });
};

export const listTicketMessagesInfiniteQueryKey = (options: Options<ListTicketMessagesData>): QueryKey<Options<ListTicketMessagesData>> => createQueryKey('listTicketMessages', options, true);

export const listTicketMessagesInfiniteOptions = (options: Options<ListTicketMessagesData>) => {
    return infiniteQueryOptions<ListTicketMessagesResponse, ListTicketMessagesError, InfiniteData<ListTicketMessagesResponse>, QueryKey<Options<ListTicketMessagesData>>, number | Pick<QueryKey<Options<ListTicketMessagesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListTicketMessagesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listTicketMessages({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTicketMessagesInfiniteQueryKey(options)
    });
};

export const createMessageQueryKey = (options: Options<CreateMessageData>) => createQueryKey('createMessage', options);

/**
 * Create a message on a ticket.
 */
export const createMessageOptions = (options: Options<CreateMessageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createMessage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createMessageQueryKey(options)
    });
};

/**
 * Create a message on a ticket.
 */
export const createMessageMutation = (options?: Partial<Options<CreateMessageData>>): UseMutationOptions<CreateMessageResponse, CreateMessageError, Options<CreateMessageData>> => {
    const mutationOptions: UseMutationOptions<CreateMessageResponse, CreateMessageError, Options<CreateMessageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createMessage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMessageCountQueryKey = (options: Options<GetMessageCountData>) => createQueryKey('getMessageCount', options);

export const getMessageCountOptions = (options: Options<GetMessageCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMessageCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMessageCountQueryKey(options)
    });
};

export const createInternalNoteQueryKey = (options: Options<CreateInternalNoteData>) => createQueryKey('createInternalNote', options);

export const createInternalNoteOptions = (options: Options<CreateInternalNoteData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createInternalNote({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createInternalNoteQueryKey(options)
    });
};

export const createInternalNoteMutation = (options?: Partial<Options<CreateInternalNoteData>>): UseMutationOptions<CreateInternalNoteResponse, DefaultError, Options<CreateInternalNoteData>> => {
    const mutationOptions: UseMutationOptions<CreateInternalNoteResponse, DefaultError, Options<CreateInternalNoteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createInternalNote({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLatestMessageQueryKey = (options: Options<GetLatestMessageData>) => createQueryKey('getLatestMessage', options);

export const getLatestMessageOptions = (options: Options<GetLatestMessageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLatestMessage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLatestMessageQueryKey(options)
    });
};

export const searchMessagesQueryKey = (options: Options<SearchMessagesData>) => createQueryKey('searchMessages', options);

export const searchMessagesOptions = (options: Options<SearchMessagesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await searchMessages({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: searchMessagesQueryKey(options)
    });
};

export const searchMessagesInfiniteQueryKey = (options: Options<SearchMessagesData>): QueryKey<Options<SearchMessagesData>> => createQueryKey('searchMessages', options, true);

export const searchMessagesInfiniteOptions = (options: Options<SearchMessagesData>) => {
    return infiniteQueryOptions<SearchMessagesResponse, SearchMessagesError, InfiniteData<SearchMessagesResponse>, QueryKey<Options<SearchMessagesData>>, number | Pick<QueryKey<Options<SearchMessagesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<SearchMessagesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await searchMessages({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: searchMessagesInfiniteQueryKey(options)
    });
};

export const listMessageAttachmentsQueryKey = (options: Options<ListMessageAttachmentsData>) => createQueryKey('listMessageAttachments', options);

export const listMessageAttachmentsOptions = (options: Options<ListMessageAttachmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listMessageAttachments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMessageAttachmentsQueryKey(options)
    });
};

export const uploadAttachmentsQueryKey = (options: Options<UploadAttachmentsData>) => createQueryKey('uploadAttachments', options);

export const uploadAttachmentsOptions = (options: Options<UploadAttachmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await uploadAttachments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: uploadAttachmentsQueryKey(options)
    });
};

export const uploadAttachmentsMutation = (options?: Partial<Options<UploadAttachmentsData>>): UseMutationOptions<UploadAttachmentsResponse, UploadAttachmentsError, Options<UploadAttachmentsData>> => {
    const mutationOptions: UseMutationOptions<UploadAttachmentsResponse, UploadAttachmentsError, Options<UploadAttachmentsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await uploadAttachments({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteAttachmentMutation = (options?: Partial<Options<DeleteAttachmentData>>): UseMutationOptions<DeleteAttachmentResponse, DeleteAttachmentError, Options<DeleteAttachmentData>> => {
    const mutationOptions: UseMutationOptions<DeleteAttachmentResponse, DeleteAttachmentError, Options<DeleteAttachmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteAttachment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeTagsFromTicketMutation = (options?: Partial<Options<RemoveTagsFromTicketData>>): UseMutationOptions<RemoveTagsFromTicketResponse, RemoveTagsFromTicketError, Options<RemoveTagsFromTicketData>> => {
    const mutationOptions: UseMutationOptions<RemoveTagsFromTicketResponse, RemoveTagsFromTicketError, Options<RemoveTagsFromTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeTagsFromTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addTagsToTicketQueryKey = (options: Options<AddTagsToTicketData>) => createQueryKey('addTagsToTicket', options);

export const addTagsToTicketOptions = (options: Options<AddTagsToTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addTagsToTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addTagsToTicketQueryKey(options)
    });
};

export const addTagsToTicketMutation = (options?: Partial<Options<AddTagsToTicketData>>): UseMutationOptions<unknown, AddTagsToTicketError, Options<AddTagsToTicketData>> => {
    const mutationOptions: UseMutationOptions<unknown, AddTagsToTicketError, Options<AddTagsToTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addTagsToTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTypingQueryKey = (options: Options<ListTypingData>) => createQueryKey('listTyping', options);

/**
 * List users typing on a ticket
 * List user IDs of agents currently typing on the specified ticket.
 */
export const listTypingOptions = (options: Options<ListTypingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTyping({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTypingQueryKey(options)
    });
};

export const typingUpdateQueryKey = (options: Options<TypingUpdateData>) => createQueryKey('typingUpdate', options);

/**
 * Set typing indicator
 * Set or clear the caller's typing state for a specific ticket.
 */
export const typingUpdateOptions = (options: Options<TypingUpdateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await typingUpdate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: typingUpdateQueryKey(options)
    });
};

/**
 * Set typing indicator
 * Set or clear the caller's typing state for a specific ticket.
 */
export const typingUpdateMutation = (options?: Partial<Options<TypingUpdateData>>): UseMutationOptions<TypingUpdateResponse, DefaultError, Options<TypingUpdateData>> => {
    const mutationOptions: UseMutationOptions<TypingUpdateResponse, DefaultError, Options<TypingUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await typingUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTicketWatchersQueryKey = (options: Options<ListTicketWatchersData>) => createQueryKey('listTicketWatchers', options);

export const listTicketWatchersOptions = (options: Options<ListTicketWatchersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTicketWatchers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTicketWatchersQueryKey(options)
    });
};

export const addTicketWatcherQueryKey = (options: Options<AddTicketWatcherData>) => createQueryKey('addTicketWatcher', options);

export const addTicketWatcherOptions = (options: Options<AddTicketWatcherData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addTicketWatcher({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addTicketWatcherQueryKey(options)
    });
};

export const addTicketWatcherMutation = (options?: Partial<Options<AddTicketWatcherData>>): UseMutationOptions<AddTicketWatcherResponse, DefaultError, Options<AddTicketWatcherData>> => {
    const mutationOptions: UseMutationOptions<AddTicketWatcherResponse, DefaultError, Options<AddTicketWatcherData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addTicketWatcher({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeTicketWatcherMutation = (options?: Partial<Options<RemoveTicketWatcherData>>): UseMutationOptions<RemoveTicketWatcherResponse, DefaultError, Options<RemoveTicketWatcherData>> => {
    const mutationOptions: UseMutationOptions<RemoveTicketWatcherResponse, DefaultError, Options<RemoveTicketWatcherData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeTicketWatcher({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listCustomFieldsQueryKey = (options: Options<ListCustomFieldsData>) => createQueryKey('listCustomFields', options);

/**
 * List user custom fields
 * List all defined user custom fields for the organization.
 */
export const listCustomFieldsOptions = (options: Options<ListCustomFieldsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listCustomFields({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listCustomFieldsQueryKey(options)
    });
};

export const createCustomFieldQueryKey = (options: Options<CreateCustomFieldData>) => createQueryKey('createCustomField', options);

/**
 * Create a user custom field
 * Define a per-organization custom field for users (e.g., plan, region).
 */
export const createCustomFieldOptions = (options: Options<CreateCustomFieldData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createCustomField({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createCustomFieldQueryKey(options)
    });
};

/**
 * Create a user custom field
 * Define a per-organization custom field for users (e.g., plan, region).
 */
export const createCustomFieldMutation = (options?: Partial<Options<CreateCustomFieldData>>): UseMutationOptions<CreateCustomFieldResponse, DefaultError, Options<CreateCustomFieldData>> => {
    const mutationOptions: UseMutationOptions<CreateCustomFieldResponse, DefaultError, Options<CreateCustomFieldData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createCustomField({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a user custom field
 * Remove a custom field definition and all associated values.
 */
export const deleteCustomFieldMutation = (options?: Partial<Options<DeleteCustomFieldData>>): UseMutationOptions<DeleteCustomFieldResponse, DefaultError, Options<DeleteCustomFieldData>> => {
    const mutationOptions: UseMutationOptions<DeleteCustomFieldResponse, DefaultError, Options<DeleteCustomFieldData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCustomField({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listSegmentsQueryKey = (options: Options<ListSegmentsData>) => createQueryKey('listSegments', options);

/**
 * List user segments
 * List all segments defined for the organization.
 */
export const listSegmentsOptions = (options: Options<ListSegmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSegments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSegmentsQueryKey(options)
    });
};

export const createSegmentQueryKey = (options: Options<CreateSegmentData>) => createQueryKey('createSegment', options);

/**
 * Create a user segment
 * Create a segment of users based on custom field rules.
 */
export const createSegmentOptions = (options: Options<CreateSegmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createSegment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createSegmentQueryKey(options)
    });
};

/**
 * Create a user segment
 * Create a segment of users based on custom field rules.
 */
export const createSegmentMutation = (options?: Partial<Options<CreateSegmentData>>): UseMutationOptions<CreateSegmentResponse, DefaultError, Options<CreateSegmentData>> => {
    const mutationOptions: UseMutationOptions<CreateSegmentResponse, DefaultError, Options<CreateSegmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createSegment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a user segment
 * Remove a user segment.
 */
export const deleteSegmentMutation = (options?: Partial<Options<DeleteSegmentData>>): UseMutationOptions<DeleteSegmentResponse, DefaultError, Options<DeleteSegmentData>> => {
    const mutationOptions: UseMutationOptions<DeleteSegmentResponse, DefaultError, Options<DeleteSegmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteSegment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a user segment
 * Update a segment's name and/or rules.
 */
export const updateSegmentMutation = (options?: Partial<Options<UpdateSegmentData>>): UseMutationOptions<UpdateSegmentResponse, DefaultError, Options<UpdateSegmentData>> => {
    const mutationOptions: UseMutationOptions<UpdateSegmentResponse, DefaultError, Options<UpdateSegmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateSegment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const evaluateSegmentQueryKey = (options: Options<EvaluateSegmentData>) => createQueryKey('evaluateSegment', options);

/**
 * Evaluate a user segment
 * Evaluate and return the list of user IDs matching the segment rules.
 */
export const evaluateSegmentOptions = (options: Options<EvaluateSegmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await evaluateSegment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: evaluateSegmentQueryKey(options)
    });
};

/**
 * Evaluate a user segment
 * Evaluate and return the list of user IDs matching the segment rules.
 */
export const evaluateSegmentMutation = (options?: Partial<Options<EvaluateSegmentData>>): UseMutationOptions<EvaluateSegmentResponse2, DefaultError, Options<EvaluateSegmentData>> => {
    const mutationOptions: UseMutationOptions<EvaluateSegmentResponse2, DefaultError, Options<EvaluateSegmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await evaluateSegment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserCustomFieldsQueryKey = (options: Options<GetUserCustomFieldsData>) => createQueryKey('getUserCustomFields', options);

/**
 * Get a user's custom field values
 * Retrieve the custom field values for a specific user in the organization.
 */
export const getUserCustomFieldsOptions = (options: Options<GetUserCustomFieldsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserCustomFields({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserCustomFieldsQueryKey(options)
    });
};

/**
 * Set a user's custom field values
 * Create or update custom field values for a specific user.
 */
export const setUserCustomFieldsMutation = (options?: Partial<Options<SetUserCustomFieldsData>>): UseMutationOptions<SetUserCustomFieldsResponse, DefaultError, Options<SetUserCustomFieldsData>> => {
    const mutationOptions: UseMutationOptions<SetUserCustomFieldsResponse, DefaultError, Options<SetUserCustomFieldsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await setUserCustomFields({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listWebhooksQueryKey = (options: Options<ListWebhooksData>) => createQueryKey('listWebhooks', options);

/**
 * List webhooks
 * List webhooks for the organization with optional filters.
 */
export const listWebhooksOptions = (options: Options<ListWebhooksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listWebhooks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listWebhooksQueryKey(options)
    });
};

export const listWebhooksInfiniteQueryKey = (options: Options<ListWebhooksData>): QueryKey<Options<ListWebhooksData>> => createQueryKey('listWebhooks', options, true);

/**
 * List webhooks
 * List webhooks for the organization with optional filters.
 */
export const listWebhooksInfiniteOptions = (options: Options<ListWebhooksData>) => {
    return infiniteQueryOptions<ListWebhooksResponse, ListWebhooksError, InfiniteData<ListWebhooksResponse>, QueryKey<Options<ListWebhooksData>>, number | Pick<QueryKey<Options<ListWebhooksData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListWebhooksData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listWebhooks({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listWebhooksInfiniteQueryKey(options)
    });
};

export const createWebhookQueryKey = (options: Options<CreateWebhookData>) => createQueryKey('createWebhook', options);

/**
 * Create webhook
 * Create a webhook endpoint subscribed to specific events.
 */
export const createWebhookOptions = (options: Options<CreateWebhookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createWebhook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createWebhookQueryKey(options)
    });
};

/**
 * Create webhook
 * Create a webhook endpoint subscribed to specific events.
 */
export const createWebhookMutation = (options?: Partial<Options<CreateWebhookData>>): UseMutationOptions<CreateWebhookResponse, CreateWebhookError, Options<CreateWebhookData>> => {
    const mutationOptions: UseMutationOptions<CreateWebhookResponse, CreateWebhookError, Options<CreateWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listWebhookEventsQueryKey = (options: Options<ListWebhookEventsData>) => createQueryKey('listWebhookEvents', options);

/**
 * List supported webhook events
 * Get the list of event types that webhooks can subscribe to.
 */
export const listWebhookEventsOptions = (options: Options<ListWebhookEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listWebhookEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listWebhookEventsQueryKey(options)
    });
};

export const sendWebhooksQueryKey = (options: Options<SendWebhooksData>) => createQueryKey('sendWebhooks', options);

/**
 * Send webhooks for event
 * Trigger subscribed webhooks for the specified event with optional context.
 */
export const sendWebhooksOptions = (options: Options<SendWebhooksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await sendWebhooks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: sendWebhooksQueryKey(options)
    });
};

/**
 * Send webhooks for event
 * Trigger subscribed webhooks for the specified event with optional context.
 */
export const sendWebhooksMutation = (options?: Partial<Options<SendWebhooksData>>): UseMutationOptions<SendWebhooksResponse, DefaultError, Options<SendWebhooksData>> => {
    const mutationOptions: UseMutationOptions<SendWebhooksResponse, DefaultError, Options<SendWebhooksData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await sendWebhooks({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWebhookStatsQueryKey = (options: Options<GetWebhookStatsData>) => createQueryKey('getWebhookStats', options);

/**
 * Get webhook statistics
 * Retrieve aggregated statistics for webhooks in the organization.
 */
export const getWebhookStatsOptions = (options: Options<GetWebhookStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWebhookStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWebhookStatsQueryKey(options)
    });
};

/**
 * Delete webhook
 * Delete a webhook by ID.
 */
export const deleteWebhookMutation = (options?: Partial<Options<DeleteWebhookData>>): UseMutationOptions<DeleteWebhookResponse, DefaultError, Options<DeleteWebhookData>> => {
    const mutationOptions: UseMutationOptions<DeleteWebhookResponse, DefaultError, Options<DeleteWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWebhookQueryKey = (options: Options<GetWebhookData>) => createQueryKey('getWebhook', options);

/**
 * Get webhook
 * Retrieve a webhook by ID.
 */
export const getWebhookOptions = (options: Options<GetWebhookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWebhook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWebhookQueryKey(options)
    });
};

/**
 * Update webhook
 * Update webhook configuration.
 */
export const updateWebhookMutation = (options?: Partial<Options<UpdateWebhookData>>): UseMutationOptions<UpdateWebhookResponse, DefaultError, Options<UpdateWebhookData>> => {
    const mutationOptions: UseMutationOptions<UpdateWebhookResponse, DefaultError, Options<UpdateWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const testWebhookQueryKey = (options: Options<TestWebhookData>) => createQueryKey('testWebhook', options);

/**
 * Test webhook
 * Send a test event to the webhook and return the delivery result.
 */
export const testWebhookOptions = (options: Options<TestWebhookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testWebhook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testWebhookQueryKey(options)
    });
};

/**
 * Test webhook
 * Send a test event to the webhook and return the delivery result.
 */
export const testWebhookMutation = (options?: Partial<Options<TestWebhookData>>): UseMutationOptions<TestWebhookResponse, DefaultError, Options<TestWebhookData>> => {
    const mutationOptions: UseMutationOptions<TestWebhookResponse, DefaultError, Options<TestWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await testWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPermissionsCatalogQueryKey = (options?: Options<GetPermissionsCatalogData>) => createQueryKey('getPermissionsCatalog', options);

/**
 * Get permissions catalog
 * List permission keys and their bitmask values.
 */
export const getPermissionsCatalogOptions = (options?: Options<GetPermissionsCatalogData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPermissionsCatalog({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPermissionsCatalogQueryKey(options)
    });
};

export const listSessionsQueryKey = (options?: Options<ListSessionsData>) => createQueryKey('listSessions', options);

/**
 * List sessions
 * List active sessions for the authenticated user.
 */
export const listSessionsOptions = (options?: Options<ListSessionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSessions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSessionsQueryKey(options)
    });
};

export const cleanupExpiredSessionsQueryKey = (options?: Options<CleanupExpiredSessionsData>) => createQueryKey('cleanupExpiredSessions', options);

/**
 * Cleanup expired sessions
 * Delete expired sessions for all users.
 */
export const cleanupExpiredSessionsOptions = (options?: Options<CleanupExpiredSessionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await cleanupExpiredSessions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: cleanupExpiredSessionsQueryKey(options)
    });
};

/**
 * Cleanup expired sessions
 * Delete expired sessions for all users.
 */
export const cleanupExpiredSessionsMutation = (options?: Partial<Options<CleanupExpiredSessionsData>>): UseMutationOptions<unknown, DefaultError, Options<CleanupExpiredSessionsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CleanupExpiredSessionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await cleanupExpiredSessions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const revokeAllSessionsQueryKey = (options: Options<RevokeAllSessionsData>) => createQueryKey('revokeAllSessions', options);

/**
 * Revoke all sessions
 * Revoke all sessions for the user, optionally keeping current session.
 */
export const revokeAllSessionsOptions = (options: Options<RevokeAllSessionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await revokeAllSessions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: revokeAllSessionsQueryKey(options)
    });
};

/**
 * Revoke all sessions
 * Revoke all sessions for the user, optionally keeping current session.
 */
export const revokeAllSessionsMutation = (options?: Partial<Options<RevokeAllSessionsData>>): UseMutationOptions<unknown, DefaultError, Options<RevokeAllSessionsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RevokeAllSessionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await revokeAllSessions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSessionStatsQueryKey = (options?: Options<GetSessionStatsData>) => createQueryKey('getSessionStats', options);

/**
 * Get session stats
 * Retrieve total, active, and expired session counts.
 */
export const getSessionStatsOptions = (options?: Options<GetSessionStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSessionStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSessionStatsQueryKey(options)
    });
};

/**
 * Revoke session
 * Revoke a specific session.
 */
export const revokeSessionMutation = (options?: Partial<Options<RevokeSessionData>>): UseMutationOptions<unknown, DefaultError, Options<RevokeSessionData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RevokeSessionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await revokeSession({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSessionQueryKey = (options: Options<GetSessionData>) => createQueryKey('getSession', options);

/**
 * Get session
 * Retrieve details for a specific session.
 */
export const getSessionOptions = (options: Options<GetSessionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSession({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSessionQueryKey(options)
    });
};

export const extendSessionQueryKey = (options: Options<ExtendSessionData>) => createQueryKey('extendSession', options);

/**
 * Extend session
 * Extend the expiration of a specific session.
 */
export const extendSessionOptions = (options: Options<ExtendSessionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await extendSession({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: extendSessionQueryKey(options)
    });
};

/**
 * Extend session
 * Extend the expiration of a specific session.
 */
export const extendSessionMutation = (options?: Partial<Options<ExtendSessionData>>): UseMutationOptions<ExtendSessionResponse, DefaultError, Options<ExtendSessionData>> => {
    const mutationOptions: UseMutationOptions<ExtendSessionResponse, DefaultError, Options<ExtendSessionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await extendSession({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSettingsCatalogQueryKey = (options?: Options<GetSettingsCatalogData>) => createQueryKey('getSettingsCatalog', options);

/**
 * Settings catalog
 * Retrieve available settings definitions and defaults.
 */
export const getSettingsCatalogOptions = (options?: Options<GetSettingsCatalogData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSettingsCatalog({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSettingsCatalogQueryKey(options)
    });
};

/**
 * Delete current user's account
 * Permanently delete the authenticated user's account after validation checks.
 */
export const deleteAccountMutation = (options?: Partial<Options<DeleteAccountData>>): UseMutationOptions<DeleteAccountResponse, DefaultError, Options<DeleteAccountData>> => {
    const mutationOptions: UseMutationOptions<DeleteAccountResponse, DefaultError, Options<DeleteAccountData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteAccount({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listApiKeysQueryKey = (options?: Options<ListApiKeysData>) => createQueryKey('listApiKeys', options);

export const listApiKeysOptions = (options?: Options<ListApiKeysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listApiKeys({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listApiKeysQueryKey(options)
    });
};

export const listApiKeysInfiniteQueryKey = (options?: Options<ListApiKeysData>): QueryKey<Options<ListApiKeysData>> => createQueryKey('listApiKeys', options, true);

export const listApiKeysInfiniteOptions = (options?: Options<ListApiKeysData>) => {
    return infiniteQueryOptions<ListApiKeysResponse, ListApiKeysError, InfiniteData<ListApiKeysResponse>, QueryKey<Options<ListApiKeysData>>, number | Pick<QueryKey<Options<ListApiKeysData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListApiKeysData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listApiKeys({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listApiKeysInfiniteQueryKey(options)
    });
};

export const createApiKeyQueryKey = (options: Options<CreateApiKeyData>) => createQueryKey('createApiKey', options);

export const createApiKeyOptions = (options: Options<CreateApiKeyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createApiKey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createApiKeyQueryKey(options)
    });
};

export const createApiKeyMutation = (options?: Partial<Options<CreateApiKeyData>>): UseMutationOptions<CreateApiKeyResponse2, CreateApiKeyError, Options<CreateApiKeyData>> => {
    const mutationOptions: UseMutationOptions<CreateApiKeyResponse2, CreateApiKeyError, Options<CreateApiKeyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createApiKey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteApiKeyMutation = (options?: Partial<Options<DeleteApiKeyData>>): UseMutationOptions<DeleteApiKeyResponse, DefaultError, Options<DeleteApiKeyData>> => {
    const mutationOptions: UseMutationOptions<DeleteApiKeyResponse, DefaultError, Options<DeleteApiKeyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteApiKey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiKeyQueryKey = (options: Options<GetApiKeyData>) => createQueryKey('getApiKey', options);

export const getApiKeyOptions = (options: Options<GetApiKeyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiKey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiKeyQueryKey(options)
    });
};

export const revokeApiKeyQueryKey = (options: Options<RevokeApiKeyData>) => createQueryKey('revokeApiKey', options);

export const revokeApiKeyOptions = (options: Options<RevokeApiKeyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await revokeApiKey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: revokeApiKeyQueryKey(options)
    });
};

export const revokeApiKeyMutation = (options?: Partial<Options<RevokeApiKeyData>>): UseMutationOptions<RevokeApiKeyResponse, DefaultError, Options<RevokeApiKeyData>> => {
    const mutationOptions: UseMutationOptions<RevokeApiKeyResponse, DefaultError, Options<RevokeApiKeyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await revokeApiKey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLoginAttemptsQueryKey = (options?: Options<GetLoginAttemptsData>) => createQueryKey('getLoginAttempts', options);

/**
 * List recent login attempts
 * Retrieve recent login attempts for the authenticated user, including failures.
 */
export const getLoginAttemptsOptions = (options?: Options<GetLoginAttemptsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLoginAttempts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLoginAttemptsQueryKey(options)
    });
};

export const getLoginHistoryQueryKey = (options?: Options<GetLoginHistoryData>) => createQueryKey('getLoginHistory', options);

/**
 * List recent login history
 * Retrieve recent login history entries for the authenticated user.
 */
export const getLoginHistoryOptions = (options?: Options<GetLoginHistoryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLoginHistory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLoginHistoryQueryKey(options)
    });
};

/**
 * Change current user's password
 * Change the authenticated user's password by providing the current and new password.
 */
export const changePasswordMutation = (options?: Partial<Options<ChangePasswordData>>): UseMutationOptions<ChangePasswordResponse, ChangePasswordError, Options<ChangePasswordData>> => {
    const mutationOptions: UseMutationOptions<ChangePasswordResponse, ChangePasswordError, Options<ChangePasswordData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await changePassword({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProfileQueryKey = (options?: Options<GetProfileData>) => createQueryKey('getProfile', options);

/**
 * Get current user's profile
 * Fetch the authenticated user's profile, including org memberships and verification status.
 */
export const getProfileOptions = (options?: Options<GetProfileData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProfile({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProfileQueryKey(options)
    });
};

/**
 * Update current user's profile
 * Update the authenticated user's name and/or email. Triggers email verification if email changes.
 */
export const updateProfileMutation = (options?: Partial<Options<UpdateProfileData>>): UseMutationOptions<UpdateProfileResponse, DefaultError, Options<UpdateProfileData>> => {
    const mutationOptions: UseMutationOptions<UpdateProfileResponse, DefaultError, Options<UpdateProfileData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateProfile({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};