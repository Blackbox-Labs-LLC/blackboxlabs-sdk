// This file is auto-generated by @hey-api/openapi-ts

import { type Options, getAttachmentStats, getAdminMetrics, downloadAttachment, disable2Fa, enable2Fa, login, logout, register, requestPasswordReset, resendVerification, resetPassword, setup2Fa, verifyEmail, createCheckout, createAdjustment, refundPayment, getPublicConfig, getSubscription, listSubscriptions, createSubscription, changeSubscription, cancelSubscription, resumeSubscription, paddleWebhook, identifyUser, sendMessage, getTicketHistoryPublic, getUserTickets, getUserOrganizations, createOrganization, findOrganizationsByEmailDomain, joinOrganization, getOrganization, acceptInvitation, autoTriage, classify, aiContext, kbSuggest, redact, rewrite, sentimentHandler, suggestReply, suggestReplyStream, summarize, summarizeStream, telemetry, translate, translateConversation, translateStream, getOrganizationAnalytics, getAgentAnalytics, getBacklogSize, getCsatByAgent, getCsatByMacro, getKnowledgeBaseAnalytics, getMacroAnalytics, getSystemAnalytics, getTicketAnalytics, getTrendAnalytics, executeAutomationRules, listAutomationRules, createAutomationRule, deleteAutomationRule, getAutomationRule, updateAutomationRule, getAutomationStats, listEvents, createEvent, exportEvents, getEventStats, streamEvents, wsEvents, wsAuth, getEvent, inviteUser, listArticles, createArticle, deleteArticle, getArticle, updateArticle, recordArticleAccept, publishArticle, reindexArticleEmbedding, unpublishArticle, listVersions, voteArticle, listCategories, createCategory, deleteCategory, updateCategory, listSections, createSection, getPublicArticles, searchPublicArticles, deleteSection, updateSection, semanticSearch, listMacros, createMacro, deleteMacroExperiment, updateMacroExperiment, getPopularMacros, renderMacroTemplate, deleteMacro, getMacro, updateMacro, listMacroExperiments, createMacroExperiment, listMacroVariants, createMacroVariant, deleteMacroVariant, updateMacroVariant, getMembers, removeMember, updateMembership, deleteMessage, getMessage, getEffectivePermissions, listAgents, heartbeat, listRoles, createRole, deleteRole, getRole, updateRole, assignRole, revokeRole, listRules, createRule, deleteRule, updateRule, workload, getAllOrganizationSettings, setOrganizationSetting, applyDataRetention, getOrgEffectiveSettings, deleteOrganizationSetting, getOrganizationSetting, checkBreaches, countdownSse, listPolicies, createPolicy, updatePolicy, listSurveys, submitSurvey, getCsatAnalytics, deleteSurvey, getSurvey, updateSurvey, listTags, createTag, getPopularTags, deleteTag, getTag, updateTag, getTagWithTickets, listTeams, createTeam, updateTeam, listMembers, addMember, removeMember2, listTickets, createTicket, bulkUpdateTickets, mergeTickets, splitTicket, listSavedViews, createSavedView, deleteTicket, getTicket, updateTicket, assignTicketTeam, clearTicketTeamAssignment, getTicketTeamAssignment, deleteDraft, getDraft, upsertDraft, aiGenerateDraft, getTicketHistory, releaseTicketLock, lockTicket, takeoverTicketLock, listTicketMessages, createMessage, getMessageCount, createInternalNote, getLatestMessage, searchMessages, listMessageAttachments, uploadAttachments, deleteAttachment, removeTagsFromTicket, addTagsToTicket, listTyping, typingUpdate, listTicketWatchers, addTicketWatcher, removeTicketWatcher, listCustomFields, createCustomField, deleteCustomField, listSegments, createSegment, deleteSegment, updateSegment, evaluateSegment, getUserCustomFields, setUserCustomFields, listWebhooks, createWebhook, listWebhookEvents, sendWebhooks, getWebhookStats, deleteWebhook, getWebhook, updateWebhook, testWebhook, getPermissionsCatalog, listSessions, cleanupExpiredSessions, revokeAllSessions, getSessionStats, revokeSession, getSession, extendSession, getSettingsCatalog, deleteAccount, listApiKeys, createApiKey, deleteApiKey, getApiKey, revokeApiKey, getLoginAttempts, getLoginHistory, changePassword, getProfile, updateProfile } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { GetAttachmentStatsData, GetAdminMetricsData, DownloadAttachmentData, Disable2FaData, Disable2FaError, Disable2FaResponse, Enable2FaData, Enable2FaError, Enable2FaResponse, LoginData, LoginError, LoginResponse, LogoutData, LogoutError, LogoutResponse, RegisterData, RegisterError, RegisterResponse2, RequestPasswordResetData, RequestPasswordResetError, RequestPasswordResetResponse, ResendVerificationData, ResendVerificationError, ResendVerificationResponse, ResetPasswordData, ResetPasswordError, ResetPasswordResponse, Setup2FaData, Setup2FaError, Setup2FaResponse2, VerifyEmailData, VerifyEmailError, VerifyEmailResponse, CreateCheckoutData, CreateCheckoutResponse2, CreateAdjustmentData, CreateAdjustmentResponse, RefundPaymentData, RefundPaymentResponse, GetPublicConfigData, GetSubscriptionData, ListSubscriptionsData, ListSubscriptionsResponse, CreateSubscriptionData, ChangeSubscriptionData, CancelSubscriptionData, ResumeSubscriptionData, PaddleWebhookData, IdentifyUserData, IdentifyUserResponse, SendMessageData, SendMessageResponse, GetTicketHistoryPublicData, GetUserTicketsData, GetUserOrganizationsData, CreateOrganizationData, CreateOrganizationResponse, FindOrganizationsByEmailDomainData, JoinOrganizationData, JoinOrganizationResponse, GetOrganizationData, AcceptInvitationData, AcceptInvitationResponse, AutoTriageData, AutoTriageResponse, ClassifyData, ClassifyError, ClassifyResponse, AiContextData, AiContextResponse2, KbSuggestData, KbSuggestError, KbSuggestResponse, RedactData, RedactError, RedactResponse, RewriteData, RewriteError, RewriteResponse, SentimentHandlerData, SentimentHandlerResponse, SuggestReplyData, SuggestReplyError, SuggestReplyResponse, SuggestReplyStreamData, SuggestReplyStreamResponse, SummarizeData, SummarizeError, SummarizeResponse, SummarizeStreamData, SummarizeStreamResponse, TelemetryData, TelemetryError, TelemetryResponse, TranslateData, TranslateError, TranslateResponse, TranslateConversationData, TranslateConversationResponse, TranslateStreamData, TranslateStreamResponse, GetOrganizationAnalyticsData, GetAgentAnalyticsData, GetBacklogSizeData, GetCsatByAgentData, GetCsatByMacroData, GetKnowledgeBaseAnalyticsData, GetMacroAnalyticsData, GetSystemAnalyticsData, GetTicketAnalyticsData, GetTrendAnalyticsData, ExecuteAutomationRulesData, ExecuteAutomationRulesResponse, ListAutomationRulesData, ListAutomationRulesResponse, CreateAutomationRuleData, CreateAutomationRuleResponse, DeleteAutomationRuleData, GetAutomationRuleData, UpdateAutomationRuleData, UpdateAutomationRuleResponse, GetAutomationStatsData, ListEventsData, ListEventsError, ListEventsResponse, CreateEventData, CreateEventError, CreateEventResponse, ExportEventsData, GetEventStatsData, StreamEventsData, WsEventsData, WsAuthData, GetEventData, InviteUserData, InviteUserResponse, ListArticlesData, ListArticlesError, ListArticlesResponse, CreateArticleData, CreateArticleError, CreateArticleResponse, DeleteArticleData, DeleteArticleError, DeleteArticleResponse, GetArticleData, UpdateArticleData, UpdateArticleError, UpdateArticleResponse, RecordArticleAcceptData, RecordArticleAcceptResponse, PublishArticleData, PublishArticleResponse, ReindexArticleEmbeddingData, UnpublishArticleData, UnpublishArticleResponse, ListVersionsData, VoteArticleData, VoteArticleResponse, ListCategoriesData, CreateCategoryData, CreateCategoryResponse, DeleteCategoryData, DeleteCategoryResponse, UpdateCategoryData, UpdateCategoryResponse, ListSectionsData, CreateSectionData, CreateSectionResponse, GetPublicArticlesData, GetPublicArticlesError, GetPublicArticlesResponse, SearchPublicArticlesData, SearchPublicArticlesError, SearchPublicArticlesResponse, DeleteSectionData, DeleteSectionResponse, UpdateSectionData, UpdateSectionResponse, SemanticSearchData, ListMacrosData, ListMacrosError, ListMacrosResponse, CreateMacroData, CreateMacroError, CreateMacroResponse, DeleteMacroExperimentData, DeleteMacroExperimentResponse, UpdateMacroExperimentData, UpdateMacroExperimentResponse, GetPopularMacrosData, RenderMacroTemplateData, RenderMacroTemplateError, RenderMacroTemplateResponse, DeleteMacroData, DeleteMacroError, DeleteMacroResponse, GetMacroData, UpdateMacroData, UpdateMacroError, UpdateMacroResponse, ListMacroExperimentsData, CreateMacroExperimentData, CreateMacroExperimentResponse, ListMacroVariantsData, CreateMacroVariantData, CreateMacroVariantResponse, DeleteMacroVariantData, DeleteMacroVariantResponse, UpdateMacroVariantData, UpdateMacroVariantResponse, GetMembersData, RemoveMemberData, RemoveMemberResponse, UpdateMembershipData, UpdateMembershipResponse, DeleteMessageData, DeleteMessageError, DeleteMessageResponse, GetMessageData, GetEffectivePermissionsData, ListAgentsData, HeartbeatData, HeartbeatResponse, ListRolesData, CreateRoleData, CreateRoleResponse, DeleteRoleData, DeleteRoleResponse, GetRoleData, UpdateRoleData, UpdateRoleResponse, AssignRoleData, AssignRoleResponse, RevokeRoleData, RevokeRoleResponse, ListRulesData, CreateRuleData, CreateRuleResponse, DeleteRuleData, DeleteRuleResponse, UpdateRuleData, UpdateRuleResponse, WorkloadData, GetAllOrganizationSettingsData, SetOrganizationSettingData, SetOrganizationSettingResponse, ApplyDataRetentionData, ApplyDataRetentionResponse, GetOrgEffectiveSettingsData, DeleteOrganizationSettingData, DeleteOrganizationSettingResponse, GetOrganizationSettingData, CheckBreachesData, CheckBreachesResponse, CountdownSseData, ListPoliciesData, CreatePolicyData, CreatePolicyResponse, UpdatePolicyData, UpdatePolicyResponse, ListSurveysData, ListSurveysResponse, SubmitSurveyData, SubmitSurveyResponse, GetCsatAnalyticsData, DeleteSurveyData, GetSurveyData, UpdateSurveyData, UpdateSurveyResponse, ListTagsData, ListTagsResponse, CreateTagData, CreateTagResponse, GetPopularTagsData, DeleteTagData, DeleteTagResponse, GetTagData, UpdateTagData, UpdateTagResponse, GetTagWithTicketsData, GetTagWithTicketsResponse, ListTeamsData, CreateTeamData, CreateTeamResponse, UpdateTeamData, UpdateTeamResponse, ListMembersData, AddMemberData, AddMemberResponse, RemoveMember2Data, RemoveMember2Response, ListTicketsData, ListTicketsError, ListTicketsResponse, CreateTicketData, CreateTicketError, CreateTicketResponse, BulkUpdateTicketsData, MergeTicketsData, SplitTicketData, SplitTicketResponse, ListSavedViewsData, CreateSavedViewData, CreateSavedViewResponse, DeleteTicketData, DeleteTicketError, DeleteTicketResponse, GetTicketData, UpdateTicketData, UpdateTicketError, UpdateTicketResponse, AssignTicketTeamData, AssignTicketTeamError, AssignTicketTeamResponse, ClearTicketTeamAssignmentData, ClearTicketTeamAssignmentResponse, GetTicketTeamAssignmentData, DeleteDraftData, DeleteDraftResponse, GetDraftData, UpsertDraftData, UpsertDraftResponse, AiGenerateDraftData, AiGenerateDraftResponse, GetTicketHistoryData, ReleaseTicketLockData, ReleaseTicketLockResponse, LockTicketData, TakeoverTicketLockData, ListTicketMessagesData, ListTicketMessagesError, ListTicketMessagesResponse, CreateMessageData, CreateMessageError, CreateMessageResponse, GetMessageCountData, CreateInternalNoteData, CreateInternalNoteResponse, GetLatestMessageData, SearchMessagesData, SearchMessagesError, SearchMessagesResponse, ListMessageAttachmentsData, UploadAttachmentsData, UploadAttachmentsError, UploadAttachmentsResponse, DeleteAttachmentData, DeleteAttachmentError, DeleteAttachmentResponse, RemoveTagsFromTicketData, RemoveTagsFromTicketError, RemoveTagsFromTicketResponse, AddTagsToTicketData, AddTagsToTicketError, ListTypingData, TypingUpdateData, TypingUpdateResponse, ListTicketWatchersData, AddTicketWatcherData, AddTicketWatcherResponse, RemoveTicketWatcherData, RemoveTicketWatcherResponse, ListCustomFieldsData, CreateCustomFieldData, CreateCustomFieldResponse, DeleteCustomFieldData, DeleteCustomFieldResponse, ListSegmentsData, CreateSegmentData, CreateSegmentResponse, DeleteSegmentData, DeleteSegmentResponse, UpdateSegmentData, UpdateSegmentResponse, EvaluateSegmentData, EvaluateSegmentResponse2, GetUserCustomFieldsData, SetUserCustomFieldsData, SetUserCustomFieldsResponse, ListWebhooksData, ListWebhooksError, ListWebhooksResponse, CreateWebhookData, CreateWebhookError, CreateWebhookResponse, ListWebhookEventsData, SendWebhooksData, SendWebhooksResponse, GetWebhookStatsData, DeleteWebhookData, DeleteWebhookResponse, GetWebhookData, UpdateWebhookData, UpdateWebhookResponse, TestWebhookData, TestWebhookResponse, GetPermissionsCatalogData, ListSessionsData, CleanupExpiredSessionsData, RevokeAllSessionsData, GetSessionStatsData, RevokeSessionData, GetSessionData, ExtendSessionData, ExtendSessionResponse, GetSettingsCatalogData, DeleteAccountData, DeleteAccountResponse, ListApiKeysData, ListApiKeysError, ListApiKeysResponse, CreateApiKeyData, CreateApiKeyError, CreateApiKeyResponse2, DeleteApiKeyData, DeleteApiKeyResponse, GetApiKeyData, RevokeApiKeyData, RevokeApiKeyResponse, GetLoginAttemptsData, GetLoginHistoryData, ChangePasswordData, ChangePasswordError, ChangePasswordResponse, GetProfileData, UpdateProfileData, UpdateProfileResponse } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getAttachmentStatsQueryKey = (options?: Options<GetAttachmentStatsData>) => createQueryKey('getAttachmentStats', options);

export const getAttachmentStatsOptions = (options?: Options<GetAttachmentStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAttachmentStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAttachmentStatsQueryKey(options)
    });
};

export const getAdminMetricsQueryKey = (options?: Options<GetAdminMetricsData>) => createQueryKey('getAdminMetrics', options);

export const getAdminMetricsOptions = (options?: Options<GetAdminMetricsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAdminMetrics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAdminMetricsQueryKey(options)
    });
};

export const downloadAttachmentQueryKey = (options: Options<DownloadAttachmentData>) => createQueryKey('downloadAttachment', options);

export const downloadAttachmentOptions = (options: Options<DownloadAttachmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await downloadAttachment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: downloadAttachmentQueryKey(options)
    });
};

export const disable2FaQueryKey = (options?: Options<Disable2FaData>) => createQueryKey('disable2Fa', options);

/**
 * Disable 2FA
 * Disable TOTP-based 2FA for the authenticated user.
 */
export const disable2FaOptions = (options?: Options<Disable2FaData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await disable2Fa({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: disable2FaQueryKey(options)
    });
};

/**
 * Disable 2FA
 * Disable TOTP-based 2FA for the authenticated user.
 */
export const disable2FaMutation = (options?: Partial<Options<Disable2FaData>>): UseMutationOptions<Disable2FaResponse, Disable2FaError, Options<Disable2FaData>> => {
    const mutationOptions: UseMutationOptions<Disable2FaResponse, Disable2FaError, Options<Disable2FaData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await disable2Fa({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const enable2FaQueryKey = (options: Options<Enable2FaData>) => createQueryKey('enable2Fa', options);

/**
 * Enable 2FA
 * Enable TOTP-based 2FA for the authenticated user.
 */
export const enable2FaOptions = (options: Options<Enable2FaData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enable2Fa({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enable2FaQueryKey(options)
    });
};

/**
 * Enable 2FA
 * Enable TOTP-based 2FA for the authenticated user.
 */
export const enable2FaMutation = (options?: Partial<Options<Enable2FaData>>): UseMutationOptions<Enable2FaResponse, Enable2FaError, Options<Enable2FaData>> => {
    const mutationOptions: UseMutationOptions<Enable2FaResponse, Enable2FaError, Options<Enable2FaData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await enable2Fa({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const loginQueryKey = (options: Options<LoginData>) => createQueryKey('login', options);

/**
 * Login
 * Authenticate a user and establish a session. Provide TOTP code if 2FA is enabled.
 */
export const loginOptions = (options: Options<LoginData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await login({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: loginQueryKey(options)
    });
};

/**
 * Login
 * Authenticate a user and establish a session. Provide TOTP code if 2FA is enabled.
 */
export const loginMutation = (options?: Partial<Options<LoginData>>): UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> => {
    const mutationOptions: UseMutationOptions<LoginResponse, LoginError, Options<LoginData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await login({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const logoutQueryKey = (options?: Options<LogoutData>) => createQueryKey('logout', options);

/**
 * Logout
 * Invalidate the current session and clear the auth cookie.
 */
export const logoutOptions = (options?: Options<LogoutData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await logout({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: logoutQueryKey(options)
    });
};

/**
 * Logout
 * Invalidate the current session and clear the auth cookie.
 */
export const logoutMutation = (options?: Partial<Options<LogoutData>>): UseMutationOptions<LogoutResponse, LogoutError, Options<LogoutData>> => {
    const mutationOptions: UseMutationOptions<LogoutResponse, LogoutError, Options<LogoutData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await logout({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const registerQueryKey = (options: Options<RegisterData>) => createQueryKey('register', options);

/**
 * Register a new user
 * Create a user account and start a session. Email verification is required.
 */
export const registerOptions = (options: Options<RegisterData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await register({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: registerQueryKey(options)
    });
};

/**
 * Register a new user
 * Create a user account and start a session. Email verification is required.
 */
export const registerMutation = (options?: Partial<Options<RegisterData>>): UseMutationOptions<RegisterResponse2, RegisterError, Options<RegisterData>> => {
    const mutationOptions: UseMutationOptions<RegisterResponse2, RegisterError, Options<RegisterData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await register({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const requestPasswordResetQueryKey = (options: Options<RequestPasswordResetData>) => createQueryKey('requestPasswordReset', options);

/**
 * Request password reset
 * Send a password reset email to the given address if it exists.
 */
export const requestPasswordResetOptions = (options: Options<RequestPasswordResetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await requestPasswordReset({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: requestPasswordResetQueryKey(options)
    });
};

/**
 * Request password reset
 * Send a password reset email to the given address if it exists.
 */
export const requestPasswordResetMutation = (options?: Partial<Options<RequestPasswordResetData>>): UseMutationOptions<RequestPasswordResetResponse, RequestPasswordResetError, Options<RequestPasswordResetData>> => {
    const mutationOptions: UseMutationOptions<RequestPasswordResetResponse, RequestPasswordResetError, Options<RequestPasswordResetData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await requestPasswordReset({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resendVerificationQueryKey = (options: Options<ResendVerificationData>) => createQueryKey('resendVerification', options);

/**
 * Resend verification email
 * Resend email verification code, with rate limiting.
 */
export const resendVerificationOptions = (options: Options<ResendVerificationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resendVerification({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resendVerificationQueryKey(options)
    });
};

/**
 * Resend verification email
 * Resend email verification code, with rate limiting.
 */
export const resendVerificationMutation = (options?: Partial<Options<ResendVerificationData>>): UseMutationOptions<ResendVerificationResponse, ResendVerificationError, Options<ResendVerificationData>> => {
    const mutationOptions: UseMutationOptions<ResendVerificationResponse, ResendVerificationError, Options<ResendVerificationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resendVerification({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resetPasswordQueryKey = (options: Options<ResetPasswordData>) => createQueryKey('resetPassword', options);

/**
 * Reset password
 * Reset the password using a token sent via email.
 */
export const resetPasswordOptions = (options: Options<ResetPasswordData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resetPassword({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resetPasswordQueryKey(options)
    });
};

/**
 * Reset password
 * Reset the password using a token sent via email.
 */
export const resetPasswordMutation = (options?: Partial<Options<ResetPasswordData>>): UseMutationOptions<ResetPasswordResponse, ResetPasswordError, Options<ResetPasswordData>> => {
    const mutationOptions: UseMutationOptions<ResetPasswordResponse, ResetPasswordError, Options<ResetPasswordData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resetPassword({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const setup2FaQueryKey = (options?: Options<Setup2FaData>) => createQueryKey('setup2Fa', options);

/**
 * Setup 2FA
 * Initiate time-based one-time password (TOTP) setup and return secret and backup codes.
 */
export const setup2FaOptions = (options?: Options<Setup2FaData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await setup2Fa({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: setup2FaQueryKey(options)
    });
};

/**
 * Setup 2FA
 * Initiate time-based one-time password (TOTP) setup and return secret and backup codes.
 */
export const setup2FaMutation = (options?: Partial<Options<Setup2FaData>>): UseMutationOptions<Setup2FaResponse2, Setup2FaError, Options<Setup2FaData>> => {
    const mutationOptions: UseMutationOptions<Setup2FaResponse2, Setup2FaError, Options<Setup2FaData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await setup2Fa({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const verifyEmailQueryKey = (options: Options<VerifyEmailData>) => createQueryKey('verifyEmail', options);

/**
 * Verify email
 * Verify the user's email address using a token.
 */
export const verifyEmailOptions = (options: Options<VerifyEmailData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await verifyEmail({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: verifyEmailQueryKey(options)
    });
};

/**
 * Verify email
 * Verify the user's email address using a token.
 */
export const verifyEmailMutation = (options?: Partial<Options<VerifyEmailData>>): UseMutationOptions<VerifyEmailResponse, VerifyEmailError, Options<VerifyEmailData>> => {
    const mutationOptions: UseMutationOptions<VerifyEmailResponse, VerifyEmailError, Options<VerifyEmailData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await verifyEmail({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createCheckoutQueryKey = (options: Options<CreateCheckoutData>) => createQueryKey('createCheckout', options);

/**
 * Create Paddle checkout
 * Creates a Paddle payment link for the given price. Optionally associates the link to a customer and organization. Use the returned URL to redirect the user to checkout.
 */
export const createCheckoutOptions = (options: Options<CreateCheckoutData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createCheckout({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createCheckoutQueryKey(options)
    });
};

/**
 * Create Paddle checkout
 * Creates a Paddle payment link for the given price. Optionally associates the link to a customer and organization. Use the returned URL to redirect the user to checkout.
 */
export const createCheckoutMutation = (options?: Partial<Options<CreateCheckoutData>>): UseMutationOptions<CreateCheckoutResponse2, DefaultError, Options<CreateCheckoutData>> => {
    const mutationOptions: UseMutationOptions<CreateCheckoutResponse2, DefaultError, Options<CreateCheckoutData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createCheckout({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createAdjustmentQueryKey = (options: Options<CreateAdjustmentData>) => createQueryKey('createAdjustment', options);

/**
 * Create invoice adjustment
 * Creates a credit or debit adjustment for the specified invoice.
 */
export const createAdjustmentOptions = (options: Options<CreateAdjustmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createAdjustment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createAdjustmentQueryKey(options)
    });
};

/**
 * Create invoice adjustment
 * Creates a credit or debit adjustment for the specified invoice.
 */
export const createAdjustmentMutation = (options?: Partial<Options<CreateAdjustmentData>>): UseMutationOptions<CreateAdjustmentResponse, DefaultError, Options<CreateAdjustmentData>> => {
    const mutationOptions: UseMutationOptions<CreateAdjustmentResponse, DefaultError, Options<CreateAdjustmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createAdjustment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const refundPaymentQueryKey = (options: Options<RefundPaymentData>) => createQueryKey('refundPayment', options);

/**
 * Refund a payment
 * Requests a refund for a given payment. Amount can be full or partial.
 */
export const refundPaymentOptions = (options: Options<RefundPaymentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await refundPayment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: refundPaymentQueryKey(options)
    });
};

/**
 * Refund a payment
 * Requests a refund for a given payment. Amount can be full or partial.
 */
export const refundPaymentMutation = (options?: Partial<Options<RefundPaymentData>>): UseMutationOptions<RefundPaymentResponse, DefaultError, Options<RefundPaymentData>> => {
    const mutationOptions: UseMutationOptions<RefundPaymentResponse, DefaultError, Options<RefundPaymentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await refundPayment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPublicConfigQueryKey = (options?: Options<GetPublicConfigData>) => createQueryKey('getPublicConfig', options);

/**
 * Public billing configuration
 * Returns Paddle client token and environment for Paddle.js initialization.
 */
export const getPublicConfigOptions = (options?: Options<GetPublicConfigData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPublicConfig({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPublicConfigQueryKey(options)
    });
};

export const getSubscriptionQueryKey = (options?: Options<GetSubscriptionData>) => createQueryKey('getSubscription', options);

/**
 * Get latest subscription snapshot for primary org
 * Returns a lightweight snapshot of the organization's latest subscription, or `status=none` if none exists.
 */
export const getSubscriptionOptions = (options?: Options<GetSubscriptionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSubscription({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSubscriptionQueryKey(options)
    });
};

export const listSubscriptionsQueryKey = (options?: Options<ListSubscriptionsData>) => createQueryKey('listSubscriptions', options);

/**
 * List subscriptions
 * Lists subscriptions for the primary organization. Filter by status and limit results.
 */
export const listSubscriptionsOptions = (options?: Options<ListSubscriptionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSubscriptions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSubscriptionsQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const listSubscriptionsInfiniteQueryKey = (options?: Options<ListSubscriptionsData>): QueryKey<Options<ListSubscriptionsData>> => createQueryKey('listSubscriptions', options, true);

/**
 * List subscriptions
 * Lists subscriptions for the primary organization. Filter by status and limit results.
 */
export const listSubscriptionsInfiniteOptions = (options?: Options<ListSubscriptionsData>) => {
    return infiniteQueryOptions<ListSubscriptionsResponse, DefaultError, InfiniteData<ListSubscriptionsResponse>, QueryKey<Options<ListSubscriptionsData>>, string | Pick<QueryKey<Options<ListSubscriptionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListSubscriptionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    cursor: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listSubscriptions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSubscriptionsInfiniteQueryKey(options)
    });
};

export const createSubscriptionQueryKey = (options: Options<CreateSubscriptionData>) => createQueryKey('createSubscription', options);

/**
 * Create subscription
 * Creates a subscription for the primary organization. Requires appropriate permissions.
 */
export const createSubscriptionOptions = (options: Options<CreateSubscriptionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createSubscription({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createSubscriptionQueryKey(options)
    });
};

/**
 * Create subscription
 * Creates a subscription for the primary organization. Requires appropriate permissions.
 */
export const createSubscriptionMutation = (options?: Partial<Options<CreateSubscriptionData>>): UseMutationOptions<unknown, DefaultError, Options<CreateSubscriptionData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CreateSubscriptionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createSubscription({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const changeSubscriptionQueryKey = (options: Options<ChangeSubscriptionData>) => createQueryKey('changeSubscription', options);

/**
 * Change subscription
 * Updates subscription quantity and/or price. Proration behavior can be specified.
 */
export const changeSubscriptionOptions = (options: Options<ChangeSubscriptionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await changeSubscription({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: changeSubscriptionQueryKey(options)
    });
};

/**
 * Change subscription
 * Updates subscription quantity and/or price. Proration behavior can be specified.
 */
export const changeSubscriptionMutation = (options?: Partial<Options<ChangeSubscriptionData>>): UseMutationOptions<unknown, DefaultError, Options<ChangeSubscriptionData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ChangeSubscriptionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await changeSubscription({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const cancelSubscriptionQueryKey = (options: Options<CancelSubscriptionData>) => createQueryKey('cancelSubscription', options);

/**
 * Cancel subscription
 * Cancels a subscription immediately or schedules cancellation at period end.
 */
export const cancelSubscriptionOptions = (options: Options<CancelSubscriptionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await cancelSubscription({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: cancelSubscriptionQueryKey(options)
    });
};

/**
 * Cancel subscription
 * Cancels a subscription immediately or schedules cancellation at period end.
 */
export const cancelSubscriptionMutation = (options?: Partial<Options<CancelSubscriptionData>>): UseMutationOptions<unknown, DefaultError, Options<CancelSubscriptionData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CancelSubscriptionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await cancelSubscription({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resumeSubscriptionQueryKey = (options: Options<ResumeSubscriptionData>) => createQueryKey('resumeSubscription', options);

/**
 * Resume subscription
 * Resumes a subscription that was scheduled to be canceled at period end.
 */
export const resumeSubscriptionOptions = (options: Options<ResumeSubscriptionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resumeSubscription({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resumeSubscriptionQueryKey(options)
    });
};

/**
 * Resume subscription
 * Resumes a subscription that was scheduled to be canceled at period end.
 */
export const resumeSubscriptionMutation = (options?: Partial<Options<ResumeSubscriptionData>>): UseMutationOptions<unknown, DefaultError, Options<ResumeSubscriptionData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ResumeSubscriptionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resumeSubscription({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const paddleWebhookQueryKey = (options?: Options<PaddleWebhookData>) => createQueryKey('paddleWebhook', options);

/**
 * Paddle webhook endpoint
 * Validates Paddle signature and processes billing events. This endpoint is intended to be called by Paddle.
 */
export const paddleWebhookOptions = (options?: Options<PaddleWebhookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await paddleWebhook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: paddleWebhookQueryKey(options)
    });
};

/**
 * Paddle webhook endpoint
 * Validates Paddle signature and processes billing events. This endpoint is intended to be called by Paddle.
 */
export const paddleWebhookMutation = (options?: Partial<Options<PaddleWebhookData>>): UseMutationOptions<unknown, DefaultError, Options<PaddleWebhookData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<PaddleWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await paddleWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const identifyUserQueryKey = (options: Options<IdentifyUserData>) => createQueryKey('identifyUser', options);

/**
 * Identify client user
 * Identify or create a client-side user by email or anonymous ID in a given org domain.
 */
export const identifyUserOptions = (options: Options<IdentifyUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await identifyUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: identifyUserQueryKey(options)
    });
};

/**
 * Identify client user
 * Identify or create a client-side user by email or anonymous ID in a given org domain.
 */
export const identifyUserMutation = (options?: Partial<Options<IdentifyUserData>>): UseMutationOptions<IdentifyUserResponse, DefaultError, Options<IdentifyUserData>> => {
    const mutationOptions: UseMutationOptions<IdentifyUserResponse, DefaultError, Options<IdentifyUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await identifyUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const sendMessageQueryKey = (options: Options<SendMessageData>) => createQueryKey('sendMessage', options);

/**
 * Submit client message
 * Submit a message from the client widget; creates a ticket and initial message.
 */
export const sendMessageOptions = (options: Options<SendMessageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await sendMessage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: sendMessageQueryKey(options)
    });
};

/**
 * Submit client message
 * Submit a message from the client widget; creates a ticket and initial message.
 */
export const sendMessageMutation = (options?: Partial<Options<SendMessageData>>): UseMutationOptions<SendMessageResponse, DefaultError, Options<SendMessageData>> => {
    const mutationOptions: UseMutationOptions<SendMessageResponse, DefaultError, Options<SendMessageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await sendMessage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTicketHistoryPublicQueryKey = (options: Options<GetTicketHistoryPublicData>) => createQueryKey('getTicketHistoryPublic', options);

/**
 * Get ticket history (public)
 * Get event history for a ticket visible to client users in the specified org domain.
 */
export const getTicketHistoryPublicOptions = (options: Options<GetTicketHistoryPublicData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTicketHistoryPublic({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTicketHistoryPublicQueryKey(options)
    });
};

export const getUserTicketsQueryKey = (options: Options<GetUserTicketsData>) => createQueryKey('getUserTickets', options);

/**
 * List client tickets
 * List tickets created by the given client user in the specified org domain.
 */
export const getUserTicketsOptions = (options: Options<GetUserTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserTicketsQueryKey(options)
    });
};

export const getUserOrganizationsQueryKey = (options?: Options<GetUserOrganizationsData>) => createQueryKey('getUserOrganizations', options);

/**
 * List organizations
 * List organizations for the current user.
 */
export const getUserOrganizationsOptions = (options?: Options<GetUserOrganizationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserOrganizations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserOrganizationsQueryKey(options)
    });
};

export const createOrganizationQueryKey = (options: Options<CreateOrganizationData>) => createQueryKey('createOrganization', options);

/**
 * Create organization
 * Create a new organization and assign the creator as Admin.
 */
export const createOrganizationOptions = (options: Options<CreateOrganizationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createOrganization({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createOrganizationQueryKey(options)
    });
};

/**
 * Create organization
 * Create a new organization and assign the creator as Admin.
 */
export const createOrganizationMutation = (options?: Partial<Options<CreateOrganizationData>>): UseMutationOptions<CreateOrganizationResponse, DefaultError, Options<CreateOrganizationData>> => {
    const mutationOptions: UseMutationOptions<CreateOrganizationResponse, DefaultError, Options<CreateOrganizationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createOrganization({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const findOrganizationsByEmailDomainQueryKey = (options: Options<FindOrganizationsByEmailDomainData>) => createQueryKey('findOrganizationsByEmailDomain', options);

/**
 * Find orgs by email domain
 * Find organizations that match the domain of an email address.
 */
export const findOrganizationsByEmailDomainOptions = (options: Options<FindOrganizationsByEmailDomainData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findOrganizationsByEmailDomain({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findOrganizationsByEmailDomainQueryKey(options)
    });
};

export const joinOrganizationQueryKey = (options: Options<JoinOrganizationData>) => createQueryKey('joinOrganization', options);

/**
 * Join organization by domain
 * Join an organization if email domain matches and setting allows.
 */
export const joinOrganizationOptions = (options: Options<JoinOrganizationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await joinOrganization({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: joinOrganizationQueryKey(options)
    });
};

/**
 * Join organization by domain
 * Join an organization if email domain matches and setting allows.
 */
export const joinOrganizationMutation = (options?: Partial<Options<JoinOrganizationData>>): UseMutationOptions<JoinOrganizationResponse, DefaultError, Options<JoinOrganizationData>> => {
    const mutationOptions: UseMutationOptions<JoinOrganizationResponse, DefaultError, Options<JoinOrganizationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await joinOrganization({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationQueryKey = (options: Options<GetOrganizationData>) => createQueryKey('getOrganization', options);

/**
 * Get organization
 * Get organization details by ID.
 */
export const getOrganizationOptions = (options: Options<GetOrganizationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrganization({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationQueryKey(options)
    });
};

export const acceptInvitationQueryKey = (options: Options<AcceptInvitationData>) => createQueryKey('acceptInvitation', options);

/**
 * Accept invitation
 * Accept a pending organization invitation.
 */
export const acceptInvitationOptions = (options: Options<AcceptInvitationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await acceptInvitation({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: acceptInvitationQueryKey(options)
    });
};

/**
 * Accept invitation
 * Accept a pending organization invitation.
 */
export const acceptInvitationMutation = (options?: Partial<Options<AcceptInvitationData>>): UseMutationOptions<AcceptInvitationResponse, DefaultError, Options<AcceptInvitationData>> => {
    const mutationOptions: UseMutationOptions<AcceptInvitationResponse, DefaultError, Options<AcceptInvitationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await acceptInvitation({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const autoTriageQueryKey = (options: Options<AutoTriageData>) => createQueryKey('autoTriage', options);

/**
 * AI auto-triage ticket
 * Suggests priority/assignee/team with confidence and reasons.
 */
export const autoTriageOptions = (options: Options<AutoTriageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await autoTriage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: autoTriageQueryKey(options)
    });
};

/**
 * AI auto-triage ticket
 * Suggests priority/assignee/team with confidence and reasons.
 */
export const autoTriageMutation = (options?: Partial<Options<AutoTriageData>>): UseMutationOptions<AutoTriageResponse, DefaultError, Options<AutoTriageData>> => {
    const mutationOptions: UseMutationOptions<AutoTriageResponse, DefaultError, Options<AutoTriageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await autoTriage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const classifyQueryKey = (options: Options<ClassifyData>) => createQueryKey('classify', options);

/**
 * Classify ticket
 * Classifies a ticket into intents, risk, priority, and tags.
 */
export const classifyOptions = (options: Options<ClassifyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await classify({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: classifyQueryKey(options)
    });
};

/**
 * Classify ticket
 * Classifies a ticket into intents, risk, priority, and tags.
 */
export const classifyMutation = (options?: Partial<Options<ClassifyData>>): UseMutationOptions<ClassifyResponse, ClassifyError, Options<ClassifyData>> => {
    const mutationOptions: UseMutationOptions<ClassifyResponse, ClassifyError, Options<ClassifyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await classify({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const aiContextQueryKey = (options: Options<AiContextData>) => createQueryKey('aiContext', options);

/**
 * Fetch AI context
 * Aggregates recent conversation, KB snippets, and user profile for prompting.
 */
export const aiContextOptions = (options: Options<AiContextData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await aiContext({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: aiContextQueryKey(options)
    });
};

/**
 * Fetch AI context
 * Aggregates recent conversation, KB snippets, and user profile for prompting.
 */
export const aiContextMutation = (options?: Partial<Options<AiContextData>>): UseMutationOptions<AiContextResponse2, DefaultError, Options<AiContextData>> => {
    const mutationOptions: UseMutationOptions<AiContextResponse2, DefaultError, Options<AiContextData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await aiContext({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const kbSuggestQueryKey = (options: Options<KbSuggestData>) => createQueryKey('kbSuggest', options);

/**
 * Suggest knowledge base articles
 * Suggests relevant knowledge base articles for the ticket context.
 */
export const kbSuggestOptions = (options: Options<KbSuggestData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await kbSuggest({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: kbSuggestQueryKey(options)
    });
};

/**
 * Suggest knowledge base articles
 * Suggests relevant knowledge base articles for the ticket context.
 */
export const kbSuggestMutation = (options?: Partial<Options<KbSuggestData>>): UseMutationOptions<KbSuggestResponse, KbSuggestError, Options<KbSuggestData>> => {
    const mutationOptions: UseMutationOptions<KbSuggestResponse, KbSuggestError, Options<KbSuggestData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await kbSuggest({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const redactQueryKey = (options: Options<RedactData>) => createQueryKey('redact', options);

/**
 * Redact PII
 * Detects and redacts PII within the provided text.
 */
export const redactOptions = (options: Options<RedactData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await redact({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: redactQueryKey(options)
    });
};

/**
 * Redact PII
 * Detects and redacts PII within the provided text.
 */
export const redactMutation = (options?: Partial<Options<RedactData>>): UseMutationOptions<RedactResponse, RedactError, Options<RedactData>> => {
    const mutationOptions: UseMutationOptions<RedactResponse, RedactError, Options<RedactData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await redact({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const rewriteQueryKey = (options: Options<RewriteData>) => createQueryKey('rewrite', options);

/**
 * Rewrite text
 * Rewrites text to a specified tone and style.
 */
export const rewriteOptions = (options: Options<RewriteData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await rewrite({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: rewriteQueryKey(options)
    });
};

/**
 * Rewrite text
 * Rewrites text to a specified tone and style.
 */
export const rewriteMutation = (options?: Partial<Options<RewriteData>>): UseMutationOptions<RewriteResponse, RewriteError, Options<RewriteData>> => {
    const mutationOptions: UseMutationOptions<RewriteResponse, RewriteError, Options<RewriteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await rewrite({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const sentimentHandlerQueryKey = (options: Options<SentimentHandlerData>) => createQueryKey('sentimentHandler', options);

/**
 * Analyze sentiment
 * Analyzes sentiment and returns label and confidence score.
 */
export const sentimentHandlerOptions = (options: Options<SentimentHandlerData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await sentimentHandler({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: sentimentHandlerQueryKey(options)
    });
};

/**
 * Analyze sentiment
 * Analyzes sentiment and returns label and confidence score.
 */
export const sentimentHandlerMutation = (options?: Partial<Options<SentimentHandlerData>>): UseMutationOptions<SentimentHandlerResponse, DefaultError, Options<SentimentHandlerData>> => {
    const mutationOptions: UseMutationOptions<SentimentHandlerResponse, DefaultError, Options<SentimentHandlerData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await sentimentHandler({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const suggestReplyQueryKey = (options: Options<SuggestReplyData>) => createQueryKey('suggestReply', options);

/**
 * Suggest AI-assisted reply
 * Generates a suggested response for a ticket based on recent context.
 */
export const suggestReplyOptions = (options: Options<SuggestReplyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await suggestReply({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: suggestReplyQueryKey(options)
    });
};

/**
 * Suggest AI-assisted reply
 * Generates a suggested response for a ticket based on recent context.
 */
export const suggestReplyMutation = (options?: Partial<Options<SuggestReplyData>>): UseMutationOptions<SuggestReplyResponse, SuggestReplyError, Options<SuggestReplyData>> => {
    const mutationOptions: UseMutationOptions<SuggestReplyResponse, SuggestReplyError, Options<SuggestReplyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await suggestReply({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const suggestReplyStreamQueryKey = (options: Options<SuggestReplyStreamData>) => createQueryKey('suggestReplyStream', options);

/**
 * Stream AI reply suggestion
 * Streams a reply suggestion as server-sent events.
 */
export const suggestReplyStreamOptions = (options: Options<SuggestReplyStreamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await suggestReplyStream({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: suggestReplyStreamQueryKey(options)
    });
};

/**
 * Stream AI reply suggestion
 * Streams a reply suggestion as server-sent events.
 */
export const suggestReplyStreamMutation = (options?: Partial<Options<SuggestReplyStreamData>>): UseMutationOptions<SuggestReplyStreamResponse, DefaultError, Options<SuggestReplyStreamData>> => {
    const mutationOptions: UseMutationOptions<SuggestReplyStreamResponse, DefaultError, Options<SuggestReplyStreamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await suggestReplyStream({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const summarizeQueryKey = (options: Options<SummarizeData>) => createQueryKey('summarize', options);

/**
 * Summarize ticket conversation
 * Produces a concise summary, key points, sentiment, and todos for a ticket.
 */
export const summarizeOptions = (options: Options<SummarizeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await summarize({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: summarizeQueryKey(options)
    });
};

/**
 * Summarize ticket conversation
 * Produces a concise summary, key points, sentiment, and todos for a ticket.
 */
export const summarizeMutation = (options?: Partial<Options<SummarizeData>>): UseMutationOptions<SummarizeResponse, SummarizeError, Options<SummarizeData>> => {
    const mutationOptions: UseMutationOptions<SummarizeResponse, SummarizeError, Options<SummarizeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await summarize({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const summarizeStreamQueryKey = (options: Options<SummarizeStreamData>) => createQueryKey('summarizeStream', options);

/**
 * Stream ticket summary
 * Streams a ticket summary as server-sent events.
 */
export const summarizeStreamOptions = (options: Options<SummarizeStreamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await summarizeStream({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: summarizeStreamQueryKey(options)
    });
};

/**
 * Stream ticket summary
 * Streams a ticket summary as server-sent events.
 */
export const summarizeStreamMutation = (options?: Partial<Options<SummarizeStreamData>>): UseMutationOptions<SummarizeStreamResponse, DefaultError, Options<SummarizeStreamData>> => {
    const mutationOptions: UseMutationOptions<SummarizeStreamResponse, DefaultError, Options<SummarizeStreamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await summarizeStream({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const telemetryQueryKey = (options: Options<TelemetryData>) => createQueryKey('telemetry', options);

/**
 * Record AI telemetry
 * Records AI usage events such as acceptance/editing of suggestions.
 */
export const telemetryOptions = (options: Options<TelemetryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await telemetry({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: telemetryQueryKey(options)
    });
};

/**
 * Record AI telemetry
 * Records AI usage events such as acceptance/editing of suggestions.
 */
export const telemetryMutation = (options?: Partial<Options<TelemetryData>>): UseMutationOptions<TelemetryResponse, TelemetryError, Options<TelemetryData>> => {
    const mutationOptions: UseMutationOptions<TelemetryResponse, TelemetryError, Options<TelemetryData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await telemetry({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const translateQueryKey = (options: Options<TranslateData>) => createQueryKey('translate', options);

/**
 * Translate text
 * Translates provided text to a target locale.
 */
export const translateOptions = (options: Options<TranslateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await translate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: translateQueryKey(options)
    });
};

/**
 * Translate text
 * Translates provided text to a target locale.
 */
export const translateMutation = (options?: Partial<Options<TranslateData>>): UseMutationOptions<TranslateResponse, TranslateError, Options<TranslateData>> => {
    const mutationOptions: UseMutationOptions<TranslateResponse, TranslateError, Options<TranslateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await translate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const translateConversationQueryKey = (options: Options<TranslateConversationData>) => createQueryKey('translateConversation', options);

/**
 * Translate entire ticket conversation
 * Translates all messages in the ticket to the target locale.
 */
export const translateConversationOptions = (options: Options<TranslateConversationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await translateConversation({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: translateConversationQueryKey(options)
    });
};

/**
 * Translate entire ticket conversation
 * Translates all messages in the ticket to the target locale.
 */
export const translateConversationMutation = (options?: Partial<Options<TranslateConversationData>>): UseMutationOptions<TranslateConversationResponse, DefaultError, Options<TranslateConversationData>> => {
    const mutationOptions: UseMutationOptions<TranslateConversationResponse, DefaultError, Options<TranslateConversationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await translateConversation({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const translateStreamQueryKey = (options: Options<TranslateStreamData>) => createQueryKey('translateStream', options);

/**
 * Stream translation
 * Streams a translation as server-sent events.
 */
export const translateStreamOptions = (options: Options<TranslateStreamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await translateStream({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: translateStreamQueryKey(options)
    });
};

/**
 * Stream translation
 * Streams a translation as server-sent events.
 */
export const translateStreamMutation = (options?: Partial<Options<TranslateStreamData>>): UseMutationOptions<TranslateStreamResponse, DefaultError, Options<TranslateStreamData>> => {
    const mutationOptions: UseMutationOptions<TranslateStreamResponse, DefaultError, Options<TranslateStreamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await translateStream({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationAnalyticsQueryKey = (options: Options<GetOrganizationAnalyticsData>) => createQueryKey('getOrganizationAnalytics', options);

/**
 * Get organization analytics
 * Retrieve an overview of ticket, agent, system, KB, and macro analytics.
 */
export const getOrganizationAnalyticsOptions = (options: Options<GetOrganizationAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrganizationAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationAnalyticsQueryKey(options)
    });
};

export const getAgentAnalyticsQueryKey = (options: Options<GetAgentAnalyticsData>) => createQueryKey('getAgentAnalytics', options);

/**
 * Get agent analytics
 * Retrieve agent performance analytics.
 */
export const getAgentAnalyticsOptions = (options: Options<GetAgentAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAgentAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAgentAnalyticsQueryKey(options)
    });
};

export const getBacklogSizeQueryKey = (options: Options<GetBacklogSizeData>) => createQueryKey('getBacklogSize', options);

/**
 * Get backlog size
 * Retrieve the number of tickets in open or pending statuses.
 */
export const getBacklogSizeOptions = (options: Options<GetBacklogSizeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBacklogSize({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBacklogSizeQueryKey(options)
    });
};

export const getCsatByAgentQueryKey = (options: Options<GetCsatByAgentData>) => createQueryKey('getCsatByAgent', options);

/**
 * Get CSAT by agent
 * Retrieve CSAT scores grouped by agent.
 */
export const getCsatByAgentOptions = (options: Options<GetCsatByAgentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCsatByAgent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCsatByAgentQueryKey(options)
    });
};

export const getCsatByMacroQueryKey = (options: Options<GetCsatByMacroData>) => createQueryKey('getCsatByMacro', options);

/**
 * Get CSAT by macro
 * Retrieve CSAT scores grouped by macro.
 */
export const getCsatByMacroOptions = (options: Options<GetCsatByMacroData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCsatByMacro({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCsatByMacroQueryKey(options)
    });
};

export const getKnowledgeBaseAnalyticsQueryKey = (options: Options<GetKnowledgeBaseAnalyticsData>) => createQueryKey('getKnowledgeBaseAnalytics', options);

/**
 * Get knowledge base analytics
 * Retrieve knowledge base statistics like article counts and views.
 */
export const getKnowledgeBaseAnalyticsOptions = (options: Options<GetKnowledgeBaseAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getKnowledgeBaseAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getKnowledgeBaseAnalyticsQueryKey(options)
    });
};

export const getMacroAnalyticsQueryKey = (options: Options<GetMacroAnalyticsData>) => createQueryKey('getMacroAnalytics', options);

/**
 * Get macro usage analytics
 * Retrieve macro usage counts and most used macros.
 */
export const getMacroAnalyticsOptions = (options: Options<GetMacroAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMacroAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMacroAnalyticsQueryKey(options)
    });
};

export const getSystemAnalyticsQueryKey = (options: Options<GetSystemAnalyticsData>) => createQueryKey('getSystemAnalytics', options);

/**
 * Get system usage analytics
 * Retrieve system usage analytics and event counts.
 */
export const getSystemAnalyticsOptions = (options: Options<GetSystemAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSystemAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSystemAnalyticsQueryKey(options)
    });
};

export const getTicketAnalyticsQueryKey = (options: Options<GetTicketAnalyticsData>) => createQueryKey('getTicketAnalytics', options);

/**
 * Get ticket analytics
 * Retrieve ticket-related analytics and metrics.
 */
export const getTicketAnalyticsOptions = (options: Options<GetTicketAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTicketAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTicketAnalyticsQueryKey(options)
    });
};

export const getTrendAnalyticsQueryKey = (options: Options<GetTrendAnalyticsData>) => createQueryKey('getTrendAnalytics', options);

/**
 * Get trend analytics
 * Retrieve time series trend data for the requested metric.
 */
export const getTrendAnalyticsOptions = (options: Options<GetTrendAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTrendAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTrendAnalyticsQueryKey(options)
    });
};

export const executeAutomationRulesQueryKey = (options: Options<ExecuteAutomationRulesData>) => createQueryKey('executeAutomationRules', options);

/**
 * Execute automation rules for trigger
 * Manually trigger execution of automation rules with optional context.
 */
export const executeAutomationRulesOptions = (options: Options<ExecuteAutomationRulesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await executeAutomationRules({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: executeAutomationRulesQueryKey(options)
    });
};

/**
 * Execute automation rules for trigger
 * Manually trigger execution of automation rules with optional context.
 */
export const executeAutomationRulesMutation = (options?: Partial<Options<ExecuteAutomationRulesData>>): UseMutationOptions<ExecuteAutomationRulesResponse, DefaultError, Options<ExecuteAutomationRulesData>> => {
    const mutationOptions: UseMutationOptions<ExecuteAutomationRulesResponse, DefaultError, Options<ExecuteAutomationRulesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await executeAutomationRules({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listAutomationRulesQueryKey = (options: Options<ListAutomationRulesData>) => createQueryKey('listAutomationRules', options);

/**
 * List automation rules
 * List automation rules with optional filters.
 */
export const listAutomationRulesOptions = (options: Options<ListAutomationRulesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listAutomationRules({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listAutomationRulesQueryKey(options)
    });
};

export const listAutomationRulesInfiniteQueryKey = (options: Options<ListAutomationRulesData>): QueryKey<Options<ListAutomationRulesData>> => createQueryKey('listAutomationRules', options, true);

/**
 * List automation rules
 * List automation rules with optional filters.
 */
export const listAutomationRulesInfiniteOptions = (options: Options<ListAutomationRulesData>) => {
    return infiniteQueryOptions<ListAutomationRulesResponse, DefaultError, InfiniteData<ListAutomationRulesResponse>, QueryKey<Options<ListAutomationRulesData>>, number | Pick<QueryKey<Options<ListAutomationRulesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListAutomationRulesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listAutomationRules({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listAutomationRulesInfiniteQueryKey(options)
    });
};

export const createAutomationRuleQueryKey = (options: Options<CreateAutomationRuleData>) => createQueryKey('createAutomationRule', options);

/**
 * Create automation rule
 * Create a new automation rule with trigger, conditions, and actions.
 */
export const createAutomationRuleOptions = (options: Options<CreateAutomationRuleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createAutomationRule({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createAutomationRuleQueryKey(options)
    });
};

/**
 * Create automation rule
 * Create a new automation rule with trigger, conditions, and actions.
 */
export const createAutomationRuleMutation = (options?: Partial<Options<CreateAutomationRuleData>>): UseMutationOptions<CreateAutomationRuleResponse, DefaultError, Options<CreateAutomationRuleData>> => {
    const mutationOptions: UseMutationOptions<CreateAutomationRuleResponse, DefaultError, Options<CreateAutomationRuleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createAutomationRule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete automation rule
 * Delete an automation rule by ID.
 */
export const deleteAutomationRuleMutation = (options?: Partial<Options<DeleteAutomationRuleData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteAutomationRuleData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteAutomationRuleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteAutomationRule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAutomationRuleQueryKey = (options: Options<GetAutomationRuleData>) => createQueryKey('getAutomationRule', options);

/**
 * Get automation rule
 * Retrieve a single automation rule by ID.
 */
export const getAutomationRuleOptions = (options: Options<GetAutomationRuleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAutomationRule({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAutomationRuleQueryKey(options)
    });
};

/**
 * Update automation rule
 * Update fields of an automation rule.
 */
export const updateAutomationRuleMutation = (options?: Partial<Options<UpdateAutomationRuleData>>): UseMutationOptions<UpdateAutomationRuleResponse, DefaultError, Options<UpdateAutomationRuleData>> => {
    const mutationOptions: UseMutationOptions<UpdateAutomationRuleResponse, DefaultError, Options<UpdateAutomationRuleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateAutomationRule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAutomationStatsQueryKey = (options: Options<GetAutomationStatsData>) => createQueryKey('getAutomationStats', options);

/**
 * Get automation statistics
 * Retrieve counts and activity stats for automation rules.
 */
export const getAutomationStatsOptions = (options: Options<GetAutomationStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAutomationStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAutomationStatsQueryKey(options)
    });
};

export const listEventsQueryKey = (options: Options<ListEventsData>) => createQueryKey('listEvents', options);

export const listEventsOptions = (options: Options<ListEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listEventsQueryKey(options)
    });
};

export const listEventsInfiniteQueryKey = (options: Options<ListEventsData>): QueryKey<Options<ListEventsData>> => createQueryKey('listEvents', options, true);

export const listEventsInfiniteOptions = (options: Options<ListEventsData>) => {
    return infiniteQueryOptions<ListEventsResponse, ListEventsError, InfiniteData<ListEventsResponse>, QueryKey<Options<ListEventsData>>, number | Pick<QueryKey<Options<ListEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listEvents({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listEventsInfiniteQueryKey(options)
    });
};

export const createEventQueryKey = (options: Options<CreateEventData>) => createQueryKey('createEvent', options);

/**
 * Create audit event
 * Creates a custom event in the audit trail.
 */
export const createEventOptions = (options: Options<CreateEventData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createEvent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createEventQueryKey(options)
    });
};

/**
 * Create audit event
 * Creates a custom event in the audit trail.
 */
export const createEventMutation = (options?: Partial<Options<CreateEventData>>): UseMutationOptions<CreateEventResponse, CreateEventError, Options<CreateEventData>> => {
    const mutationOptions: UseMutationOptions<CreateEventResponse, CreateEventError, Options<CreateEventData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createEvent({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const exportEventsQueryKey = (options: Options<ExportEventsData>) => createQueryKey('exportEvents', options);

export const exportEventsOptions = (options: Options<ExportEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await exportEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: exportEventsQueryKey(options)
    });
};

export const getEventStatsQueryKey = (options: Options<GetEventStatsData>) => createQueryKey('getEventStats', options);

export const getEventStatsOptions = (options: Options<GetEventStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEventStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEventStatsQueryKey(options)
    });
};

export const streamEventsQueryKey = (options: Options<StreamEventsData>) => createQueryKey('streamEvents', options);

export const streamEventsOptions = (options: Options<StreamEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await streamEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: streamEventsQueryKey(options)
    });
};

export const wsEventsQueryKey = (options: Options<WsEventsData>) => createQueryKey('wsEvents', options);

/**
 * WebSocket events stream
 * Upgrades to WebSocket for realtime org events.
 *
 * Auth: This endpoint does not use bearerAuth; authenticate in-band by sending {op:'auth', token} with the short-lived JWT obtained from /events/ws/init.
 *
 * Usage:
 *
 * 1) Connect WS to this endpoint.
 * 2) Server hello: {"op":"hello","conn_id":"...","heartbeat_ms":30000,"max_backlog":500}.
 * 3) Send auth: {"op":"auth","token":"<jwt>"}.
 * 4) On {"op":"authok"}, subscribe to topics and receive events.
 * 5) Before expiry you'll receive {"op":"authexpiring"}; fetch a new token from /events/ws/init and send a new auth without reconnecting.
 *
 * Client envelopes (JSON): subscribe/unsubscribe/resume/ping as documented above.
 * Server envelopes (JSON): hello/event/pong/error/authok/authexpiring.
 */
export const wsEventsOptions = (options: Options<WsEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await wsEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: wsEventsQueryKey(options)
    });
};

export const wsAuthQueryKey = (options: Options<WsAuthData>) => createQueryKey('wsAuth', options);

/**
 * Get WebSocket URL and token
 * Returns a ws(s) URL and a short-lived JWT for establishing the WS connection. The server will send an `error` event with code `TOKEN_EXPIRING` ~60s before expiry to prompt re-auth.
 */
export const wsAuthOptions = (options: Options<WsAuthData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await wsAuth({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: wsAuthQueryKey(options)
    });
};

export const getEventQueryKey = (options: Options<GetEventData>) => createQueryKey('getEvent', options);

export const getEventOptions = (options: Options<GetEventData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEvent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEventQueryKey(options)
    });
};

export const inviteUserQueryKey = (options: Options<InviteUserData>) => createQueryKey('inviteUser', options);

/**
 * Invite user
 * Invite a user to join the organization.
 */
export const inviteUserOptions = (options: Options<InviteUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await inviteUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: inviteUserQueryKey(options)
    });
};

/**
 * Invite user
 * Invite a user to join the organization.
 */
export const inviteUserMutation = (options?: Partial<Options<InviteUserData>>): UseMutationOptions<InviteUserResponse, DefaultError, Options<InviteUserData>> => {
    const mutationOptions: UseMutationOptions<InviteUserResponse, DefaultError, Options<InviteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await inviteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listArticlesQueryKey = (options: Options<ListArticlesData>) => createQueryKey('listArticles', options);

export const listArticlesOptions = (options: Options<ListArticlesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listArticles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listArticlesQueryKey(options)
    });
};

export const listArticlesInfiniteQueryKey = (options: Options<ListArticlesData>): QueryKey<Options<ListArticlesData>> => createQueryKey('listArticles', options, true);

export const listArticlesInfiniteOptions = (options: Options<ListArticlesData>) => {
    return infiniteQueryOptions<ListArticlesResponse, ListArticlesError, InfiniteData<ListArticlesResponse>, QueryKey<Options<ListArticlesData>>, number | Pick<QueryKey<Options<ListArticlesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListArticlesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listArticles({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listArticlesInfiniteQueryKey(options)
    });
};

export const createArticleQueryKey = (options: Options<CreateArticleData>) => createQueryKey('createArticle', options);

export const createArticleOptions = (options: Options<CreateArticleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createArticle({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createArticleQueryKey(options)
    });
};

export const createArticleMutation = (options?: Partial<Options<CreateArticleData>>): UseMutationOptions<CreateArticleResponse, CreateArticleError, Options<CreateArticleData>> => {
    const mutationOptions: UseMutationOptions<CreateArticleResponse, CreateArticleError, Options<CreateArticleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createArticle({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteArticleMutation = (options?: Partial<Options<DeleteArticleData>>): UseMutationOptions<DeleteArticleResponse, DeleteArticleError, Options<DeleteArticleData>> => {
    const mutationOptions: UseMutationOptions<DeleteArticleResponse, DeleteArticleError, Options<DeleteArticleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteArticle({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getArticleQueryKey = (options: Options<GetArticleData>) => createQueryKey('getArticle', options);

export const getArticleOptions = (options: Options<GetArticleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getArticle({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getArticleQueryKey(options)
    });
};

export const updateArticleMutation = (options?: Partial<Options<UpdateArticleData>>): UseMutationOptions<UpdateArticleResponse, UpdateArticleError, Options<UpdateArticleData>> => {
    const mutationOptions: UseMutationOptions<UpdateArticleResponse, UpdateArticleError, Options<UpdateArticleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateArticle({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const recordArticleAcceptQueryKey = (options: Options<RecordArticleAcceptData>) => createQueryKey('recordArticleAccept', options);

export const recordArticleAcceptOptions = (options: Options<RecordArticleAcceptData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await recordArticleAccept({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: recordArticleAcceptQueryKey(options)
    });
};

export const recordArticleAcceptMutation = (options?: Partial<Options<RecordArticleAcceptData>>): UseMutationOptions<RecordArticleAcceptResponse, DefaultError, Options<RecordArticleAcceptData>> => {
    const mutationOptions: UseMutationOptions<RecordArticleAcceptResponse, DefaultError, Options<RecordArticleAcceptData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await recordArticleAccept({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const publishArticleQueryKey = (options: Options<PublishArticleData>) => createQueryKey('publishArticle', options);

export const publishArticleOptions = (options: Options<PublishArticleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await publishArticle({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: publishArticleQueryKey(options)
    });
};

export const publishArticleMutation = (options?: Partial<Options<PublishArticleData>>): UseMutationOptions<PublishArticleResponse, DefaultError, Options<PublishArticleData>> => {
    const mutationOptions: UseMutationOptions<PublishArticleResponse, DefaultError, Options<PublishArticleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await publishArticle({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const reindexArticleEmbeddingQueryKey = (options: Options<ReindexArticleEmbeddingData>) => createQueryKey('reindexArticleEmbedding', options);

export const reindexArticleEmbeddingOptions = (options: Options<ReindexArticleEmbeddingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await reindexArticleEmbedding({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: reindexArticleEmbeddingQueryKey(options)
    });
};

export const reindexArticleEmbeddingMutation = (options?: Partial<Options<ReindexArticleEmbeddingData>>): UseMutationOptions<unknown, DefaultError, Options<ReindexArticleEmbeddingData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ReindexArticleEmbeddingData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await reindexArticleEmbedding({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const unpublishArticleQueryKey = (options: Options<UnpublishArticleData>) => createQueryKey('unpublishArticle', options);

export const unpublishArticleOptions = (options: Options<UnpublishArticleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await unpublishArticle({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: unpublishArticleQueryKey(options)
    });
};

export const unpublishArticleMutation = (options?: Partial<Options<UnpublishArticleData>>): UseMutationOptions<UnpublishArticleResponse, DefaultError, Options<UnpublishArticleData>> => {
    const mutationOptions: UseMutationOptions<UnpublishArticleResponse, DefaultError, Options<UnpublishArticleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await unpublishArticle({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listVersionsQueryKey = (options: Options<ListVersionsData>) => createQueryKey('listVersions', options);

export const listVersionsOptions = (options: Options<ListVersionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listVersions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listVersionsQueryKey(options)
    });
};

export const voteArticleQueryKey = (options: Options<VoteArticleData>) => createQueryKey('voteArticle', options);

export const voteArticleOptions = (options: Options<VoteArticleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await voteArticle({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: voteArticleQueryKey(options)
    });
};

export const voteArticleMutation = (options?: Partial<Options<VoteArticleData>>): UseMutationOptions<VoteArticleResponse, DefaultError, Options<VoteArticleData>> => {
    const mutationOptions: UseMutationOptions<VoteArticleResponse, DefaultError, Options<VoteArticleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await voteArticle({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listCategoriesQueryKey = (options: Options<ListCategoriesData>) => createQueryKey('listCategories', options);

export const listCategoriesOptions = (options: Options<ListCategoriesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listCategories({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listCategoriesQueryKey(options)
    });
};

export const createCategoryQueryKey = (options: Options<CreateCategoryData>) => createQueryKey('createCategory', options);

export const createCategoryOptions = (options: Options<CreateCategoryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createCategory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createCategoryQueryKey(options)
    });
};

export const createCategoryMutation = (options?: Partial<Options<CreateCategoryData>>): UseMutationOptions<CreateCategoryResponse, DefaultError, Options<CreateCategoryData>> => {
    const mutationOptions: UseMutationOptions<CreateCategoryResponse, DefaultError, Options<CreateCategoryData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createCategory({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteCategoryMutation = (options?: Partial<Options<DeleteCategoryData>>): UseMutationOptions<DeleteCategoryResponse, DefaultError, Options<DeleteCategoryData>> => {
    const mutationOptions: UseMutationOptions<DeleteCategoryResponse, DefaultError, Options<DeleteCategoryData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCategory({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateCategoryMutation = (options?: Partial<Options<UpdateCategoryData>>): UseMutationOptions<UpdateCategoryResponse, DefaultError, Options<UpdateCategoryData>> => {
    const mutationOptions: UseMutationOptions<UpdateCategoryResponse, DefaultError, Options<UpdateCategoryData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateCategory({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listSectionsQueryKey = (options: Options<ListSectionsData>) => createQueryKey('listSections', options);

export const listSectionsOptions = (options: Options<ListSectionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSections({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSectionsQueryKey(options)
    });
};

export const createSectionQueryKey = (options: Options<CreateSectionData>) => createQueryKey('createSection', options);

export const createSectionOptions = (options: Options<CreateSectionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createSection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createSectionQueryKey(options)
    });
};

export const createSectionMutation = (options?: Partial<Options<CreateSectionData>>): UseMutationOptions<CreateSectionResponse, DefaultError, Options<CreateSectionData>> => {
    const mutationOptions: UseMutationOptions<CreateSectionResponse, DefaultError, Options<CreateSectionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createSection({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPublicArticlesQueryKey = (options: Options<GetPublicArticlesData>) => createQueryKey('getPublicArticles', options);

export const getPublicArticlesOptions = (options: Options<GetPublicArticlesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPublicArticles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPublicArticlesQueryKey(options)
    });
};

export const getPublicArticlesInfiniteQueryKey = (options: Options<GetPublicArticlesData>): QueryKey<Options<GetPublicArticlesData>> => createQueryKey('getPublicArticles', options, true);

export const getPublicArticlesInfiniteOptions = (options: Options<GetPublicArticlesData>) => {
    return infiniteQueryOptions<GetPublicArticlesResponse, GetPublicArticlesError, InfiniteData<GetPublicArticlesResponse>, QueryKey<Options<GetPublicArticlesData>>, number | Pick<QueryKey<Options<GetPublicArticlesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetPublicArticlesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getPublicArticles({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPublicArticlesInfiniteQueryKey(options)
    });
};

export const searchPublicArticlesQueryKey = (options: Options<SearchPublicArticlesData>) => createQueryKey('searchPublicArticles', options);

export const searchPublicArticlesOptions = (options: Options<SearchPublicArticlesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await searchPublicArticles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: searchPublicArticlesQueryKey(options)
    });
};

export const searchPublicArticlesInfiniteQueryKey = (options: Options<SearchPublicArticlesData>): QueryKey<Options<SearchPublicArticlesData>> => createQueryKey('searchPublicArticles', options, true);

export const searchPublicArticlesInfiniteOptions = (options: Options<SearchPublicArticlesData>) => {
    return infiniteQueryOptions<SearchPublicArticlesResponse, SearchPublicArticlesError, InfiniteData<SearchPublicArticlesResponse>, QueryKey<Options<SearchPublicArticlesData>>, number | Pick<QueryKey<Options<SearchPublicArticlesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<SearchPublicArticlesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await searchPublicArticles({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: searchPublicArticlesInfiniteQueryKey(options)
    });
};

export const deleteSectionMutation = (options?: Partial<Options<DeleteSectionData>>): UseMutationOptions<DeleteSectionResponse, DefaultError, Options<DeleteSectionData>> => {
    const mutationOptions: UseMutationOptions<DeleteSectionResponse, DefaultError, Options<DeleteSectionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteSection({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateSectionMutation = (options?: Partial<Options<UpdateSectionData>>): UseMutationOptions<UpdateSectionResponse, DefaultError, Options<UpdateSectionData>> => {
    const mutationOptions: UseMutationOptions<UpdateSectionResponse, DefaultError, Options<UpdateSectionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateSection({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const semanticSearchQueryKey = (options: Options<SemanticSearchData>) => createQueryKey('semanticSearch', options);

export const semanticSearchOptions = (options: Options<SemanticSearchData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await semanticSearch({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: semanticSearchQueryKey(options)
    });
};

export const listMacrosQueryKey = (options: Options<ListMacrosData>) => createQueryKey('listMacros', options);

/**
 * List macros
 * List macros with search and pagination.
 */
export const listMacrosOptions = (options: Options<ListMacrosData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listMacros({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMacrosQueryKey(options)
    });
};

export const listMacrosInfiniteQueryKey = (options: Options<ListMacrosData>): QueryKey<Options<ListMacrosData>> => createQueryKey('listMacros', options, true);

/**
 * List macros
 * List macros with search and pagination.
 */
export const listMacrosInfiniteOptions = (options: Options<ListMacrosData>) => {
    return infiniteQueryOptions<ListMacrosResponse, ListMacrosError, InfiniteData<ListMacrosResponse>, QueryKey<Options<ListMacrosData>>, number | Pick<QueryKey<Options<ListMacrosData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListMacrosData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listMacros({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMacrosInfiniteQueryKey(options)
    });
};

export const createMacroQueryKey = (options: Options<CreateMacroData>) => createQueryKey('createMacro', options);

/**
 * Create a macro
 * Create a reusable response template. Requires MANAGE_MACROS.
 */
export const createMacroOptions = (options: Options<CreateMacroData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createMacro({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createMacroQueryKey(options)
    });
};

/**
 * Create a macro
 * Create a reusable response template. Requires MANAGE_MACROS.
 */
export const createMacroMutation = (options?: Partial<Options<CreateMacroData>>): UseMutationOptions<CreateMacroResponse, CreateMacroError, Options<CreateMacroData>> => {
    const mutationOptions: UseMutationOptions<CreateMacroResponse, CreateMacroError, Options<CreateMacroData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createMacro({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete macro experiment
 * Delete an experiment by ID.
 */
export const deleteMacroExperimentMutation = (options?: Partial<Options<DeleteMacroExperimentData>>): UseMutationOptions<DeleteMacroExperimentResponse, DefaultError, Options<DeleteMacroExperimentData>> => {
    const mutationOptions: UseMutationOptions<DeleteMacroExperimentResponse, DefaultError, Options<DeleteMacroExperimentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteMacroExperiment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update macro experiment
 * Update name, status, or variant weights for an experiment.
 */
export const updateMacroExperimentMutation = (options?: Partial<Options<UpdateMacroExperimentData>>): UseMutationOptions<UpdateMacroExperimentResponse, DefaultError, Options<UpdateMacroExperimentData>> => {
    const mutationOptions: UseMutationOptions<UpdateMacroExperimentResponse, DefaultError, Options<UpdateMacroExperimentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateMacroExperiment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPopularMacrosQueryKey = (options: Options<GetPopularMacrosData>) => createQueryKey('getPopularMacros', options);

/**
 * Popular macros
 * List recently used macros for quick access.
 */
export const getPopularMacrosOptions = (options: Options<GetPopularMacrosData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPopularMacros({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPopularMacrosQueryKey(options)
    });
};

export const renderMacroTemplateQueryKey = (options: Options<RenderMacroTemplateData>) => createQueryKey('renderMacroTemplate', options);

/**
 * Render macro
 * Render a macro template with variables and optional channel/locale.
 */
export const renderMacroTemplateOptions = (options: Options<RenderMacroTemplateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await renderMacroTemplate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: renderMacroTemplateQueryKey(options)
    });
};

/**
 * Render macro
 * Render a macro template with variables and optional channel/locale.
 */
export const renderMacroTemplateMutation = (options?: Partial<Options<RenderMacroTemplateData>>): UseMutationOptions<RenderMacroTemplateResponse, RenderMacroTemplateError, Options<RenderMacroTemplateData>> => {
    const mutationOptions: UseMutationOptions<RenderMacroTemplateResponse, RenderMacroTemplateError, Options<RenderMacroTemplateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await renderMacroTemplate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete macro
 * Delete a macro by ID.
 */
export const deleteMacroMutation = (options?: Partial<Options<DeleteMacroData>>): UseMutationOptions<DeleteMacroResponse, DeleteMacroError, Options<DeleteMacroData>> => {
    const mutationOptions: UseMutationOptions<DeleteMacroResponse, DeleteMacroError, Options<DeleteMacroData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteMacro({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMacroQueryKey = (options: Options<GetMacroData>) => createQueryKey('getMacro', options);

/**
 * Get macro
 * Retrieve a macro by ID.
 */
export const getMacroOptions = (options: Options<GetMacroData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMacro({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMacroQueryKey(options)
    });
};

/**
 * Update macro
 * Update macro properties. Requires MANAGE_MACROS.
 */
export const updateMacroMutation = (options?: Partial<Options<UpdateMacroData>>): UseMutationOptions<UpdateMacroResponse, UpdateMacroError, Options<UpdateMacroData>> => {
    const mutationOptions: UseMutationOptions<UpdateMacroResponse, UpdateMacroError, Options<UpdateMacroData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateMacro({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listMacroExperimentsQueryKey = (options: Options<ListMacroExperimentsData>) => createQueryKey('listMacroExperiments', options);

/**
 * List macro experiments
 * List experiments for a macro.
 */
export const listMacroExperimentsOptions = (options: Options<ListMacroExperimentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listMacroExperiments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMacroExperimentsQueryKey(options)
    });
};

export const createMacroExperimentQueryKey = (options: Options<CreateMacroExperimentData>) => createQueryKey('createMacroExperiment', options);

/**
 * Create macro experiment
 * Create an experiment to A/B test macro variants.
 */
export const createMacroExperimentOptions = (options: Options<CreateMacroExperimentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createMacroExperiment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createMacroExperimentQueryKey(options)
    });
};

/**
 * Create macro experiment
 * Create an experiment to A/B test macro variants.
 */
export const createMacroExperimentMutation = (options?: Partial<Options<CreateMacroExperimentData>>): UseMutationOptions<CreateMacroExperimentResponse, DefaultError, Options<CreateMacroExperimentData>> => {
    const mutationOptions: UseMutationOptions<CreateMacroExperimentResponse, DefaultError, Options<CreateMacroExperimentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createMacroExperiment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listMacroVariantsQueryKey = (options: Options<ListMacroVariantsData>) => createQueryKey('listMacroVariants', options);

/**
 * List macro variants
 * List channel/locale variants for a macro.
 */
export const listMacroVariantsOptions = (options: Options<ListMacroVariantsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listMacroVariants({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMacroVariantsQueryKey(options)
    });
};

export const createMacroVariantQueryKey = (options: Options<CreateMacroVariantData>) => createQueryKey('createMacroVariant', options);

/**
 * Create macro variant
 * Create a channel/locale variant for a macro.
 */
export const createMacroVariantOptions = (options: Options<CreateMacroVariantData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createMacroVariant({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createMacroVariantQueryKey(options)
    });
};

/**
 * Create macro variant
 * Create a channel/locale variant for a macro.
 */
export const createMacroVariantMutation = (options?: Partial<Options<CreateMacroVariantData>>): UseMutationOptions<CreateMacroVariantResponse, DefaultError, Options<CreateMacroVariantData>> => {
    const mutationOptions: UseMutationOptions<CreateMacroVariantResponse, DefaultError, Options<CreateMacroVariantData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createMacroVariant({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete macro variant
 * Delete a macro variant by ID.
 */
export const deleteMacroVariantMutation = (options?: Partial<Options<DeleteMacroVariantData>>): UseMutationOptions<DeleteMacroVariantResponse, DefaultError, Options<DeleteMacroVariantData>> => {
    const mutationOptions: UseMutationOptions<DeleteMacroVariantResponse, DefaultError, Options<DeleteMacroVariantData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteMacroVariant({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update macro variant
 * Update a specific macro variant.
 */
export const updateMacroVariantMutation = (options?: Partial<Options<UpdateMacroVariantData>>): UseMutationOptions<UpdateMacroVariantResponse, DefaultError, Options<UpdateMacroVariantData>> => {
    const mutationOptions: UseMutationOptions<UpdateMacroVariantResponse, DefaultError, Options<UpdateMacroVariantData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateMacroVariant({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMembersQueryKey = (options: Options<GetMembersData>) => createQueryKey('getMembers', options);

/**
 * List members
 * List organization members and their statuses.
 */
export const getMembersOptions = (options: Options<GetMembersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMembers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMembersQueryKey(options)
    });
};

/**
 * Remove member
 * Remove a member from the organization.
 */
export const removeMemberMutation = (options?: Partial<Options<RemoveMemberData>>): UseMutationOptions<RemoveMemberResponse, DefaultError, Options<RemoveMemberData>> => {
    const mutationOptions: UseMutationOptions<RemoveMemberResponse, DefaultError, Options<RemoveMemberData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeMember({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update membership
 * Update membership status (active, invited, requested, suspended).
 */
export const updateMembershipMutation = (options?: Partial<Options<UpdateMembershipData>>): UseMutationOptions<UpdateMembershipResponse, DefaultError, Options<UpdateMembershipData>> => {
    const mutationOptions: UseMutationOptions<UpdateMembershipResponse, DefaultError, Options<UpdateMembershipData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateMembership({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteMessageMutation = (options?: Partial<Options<DeleteMessageData>>): UseMutationOptions<DeleteMessageResponse, DeleteMessageError, Options<DeleteMessageData>> => {
    const mutationOptions: UseMutationOptions<DeleteMessageResponse, DeleteMessageError, Options<DeleteMessageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteMessage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMessageQueryKey = (options: Options<GetMessageData>) => createQueryKey('getMessage', options);

export const getMessageOptions = (options: Options<GetMessageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMessage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMessageQueryKey(options)
    });
};

export const getEffectivePermissionsQueryKey = (options: Options<GetEffectivePermissionsData>) => createQueryKey('getEffectivePermissions', options);

/**
 * Get effective permissions
 * Compute effective permission bitmask for the current user in the organization.
 */
export const getEffectivePermissionsOptions = (options: Options<GetEffectivePermissionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getEffectivePermissions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getEffectivePermissionsQueryKey(options)
    });
};

export const listAgentsQueryKey = (options: Options<ListAgentsData>) => createQueryKey('listAgents', options);

/**
 * List online agents
 * List agents with recent presence heartbeats and their current ticket context.
 */
export const listAgentsOptions = (options: Options<ListAgentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listAgents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listAgentsQueryKey(options)
    });
};

export const heartbeatQueryKey = (options: Options<HeartbeatData>) => createQueryKey('heartbeat', options);

/**
 * Send agent presence heartbeat
 * Send a presence heartbeat to update agent status and current/editing ticket context.
 */
export const heartbeatOptions = (options: Options<HeartbeatData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await heartbeat({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: heartbeatQueryKey(options)
    });
};

/**
 * Send agent presence heartbeat
 * Send a presence heartbeat to update agent status and current/editing ticket context.
 */
export const heartbeatMutation = (options?: Partial<Options<HeartbeatData>>): UseMutationOptions<HeartbeatResponse, DefaultError, Options<HeartbeatData>> => {
    const mutationOptions: UseMutationOptions<HeartbeatResponse, DefaultError, Options<HeartbeatData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await heartbeat({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listRolesQueryKey = (options: Options<ListRolesData>) => createQueryKey('listRoles', options);

/**
 * List roles
 * List roles for the organization ordered by position.
 */
export const listRolesOptions = (options: Options<ListRolesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listRoles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listRolesQueryKey(options)
    });
};

export const createRoleQueryKey = (options: Options<CreateRoleData>) => createQueryKey('createRole', options);

/**
 * Create role
 * Create a new role with a permission bitmask and display settings.
 */
export const createRoleOptions = (options: Options<CreateRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createRoleQueryKey(options)
    });
};

/**
 * Create role
 * Create a new role with a permission bitmask and display settings.
 */
export const createRoleMutation = (options?: Partial<Options<CreateRoleData>>): UseMutationOptions<CreateRoleResponse, DefaultError, Options<CreateRoleData>> => {
    const mutationOptions: UseMutationOptions<CreateRoleResponse, DefaultError, Options<CreateRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete role
 * Delete a role by ID.
 */
export const deleteRoleMutation = (options?: Partial<Options<DeleteRoleData>>): UseMutationOptions<DeleteRoleResponse, DefaultError, Options<DeleteRoleData>> => {
    const mutationOptions: UseMutationOptions<DeleteRoleResponse, DefaultError, Options<DeleteRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRoleQueryKey = (options: Options<GetRoleData>) => createQueryKey('getRole', options);

/**
 * Get role
 * Retrieve a role by ID.
 */
export const getRoleOptions = (options: Options<GetRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRoleQueryKey(options)
    });
};

/**
 * Update role
 * Update role fields like name, color, position, and permissions.
 */
export const updateRoleMutation = (options?: Partial<Options<UpdateRoleData>>): UseMutationOptions<UpdateRoleResponse, DefaultError, Options<UpdateRoleData>> => {
    const mutationOptions: UseMutationOptions<UpdateRoleResponse, DefaultError, Options<UpdateRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const assignRoleQueryKey = (options: Options<AssignRoleData>) => createQueryKey('assignRole', options);

/**
 * Assign role
 * Assign a role to a user.
 */
export const assignRoleOptions = (options: Options<AssignRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignRoleQueryKey(options)
    });
};

/**
 * Assign role
 * Assign a role to a user.
 */
export const assignRoleMutation = (options?: Partial<Options<AssignRoleData>>): UseMutationOptions<AssignRoleResponse, DefaultError, Options<AssignRoleData>> => {
    const mutationOptions: UseMutationOptions<AssignRoleResponse, DefaultError, Options<AssignRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await assignRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const revokeRoleQueryKey = (options: Options<RevokeRoleData>) => createQueryKey('revokeRole', options);

/**
 * Revoke role
 * Revoke a role from a user.
 */
export const revokeRoleOptions = (options: Options<RevokeRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await revokeRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: revokeRoleQueryKey(options)
    });
};

/**
 * Revoke role
 * Revoke a role from a user.
 */
export const revokeRoleMutation = (options?: Partial<Options<RevokeRoleData>>): UseMutationOptions<RevokeRoleResponse, DefaultError, Options<RevokeRoleData>> => {
    const mutationOptions: UseMutationOptions<RevokeRoleResponse, DefaultError, Options<RevokeRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await revokeRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listRulesQueryKey = (options: Options<ListRulesData>) => createQueryKey('listRules', options);

/**
 * List routing rules
 * List routing rules for an organization.
 */
export const listRulesOptions = (options: Options<ListRulesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listRules({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listRulesQueryKey(options)
    });
};

export const createRuleQueryKey = (options: Options<CreateRuleData>) => createQueryKey('createRule', options);

/**
 * Create routing rule
 * Create a ticket routing rule with strategy, conditions, and actions.
 */
export const createRuleOptions = (options: Options<CreateRuleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createRule({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createRuleQueryKey(options)
    });
};

/**
 * Create routing rule
 * Create a ticket routing rule with strategy, conditions, and actions.
 */
export const createRuleMutation = (options?: Partial<Options<CreateRuleData>>): UseMutationOptions<CreateRuleResponse, DefaultError, Options<CreateRuleData>> => {
    const mutationOptions: UseMutationOptions<CreateRuleResponse, DefaultError, Options<CreateRuleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createRule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete routing rule
 * Delete a routing rule by ID.
 */
export const deleteRuleMutation = (options?: Partial<Options<DeleteRuleData>>): UseMutationOptions<DeleteRuleResponse, DefaultError, Options<DeleteRuleData>> => {
    const mutationOptions: UseMutationOptions<DeleteRuleResponse, DefaultError, Options<DeleteRuleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteRule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update routing rule
 * Update routing rule properties.
 */
export const updateRuleMutation = (options?: Partial<Options<UpdateRuleData>>): UseMutationOptions<UpdateRuleResponse, DefaultError, Options<UpdateRuleData>> => {
    const mutationOptions: UseMutationOptions<UpdateRuleResponse, DefaultError, Options<UpdateRuleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateRule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const workloadQueryKey = (options: Options<WorkloadData>) => createQueryKey('workload', options);

/**
 * Agent workload
 * Get open ticket counts per active org member.
 */
export const workloadOptions = (options: Options<WorkloadData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await workload({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: workloadQueryKey(options)
    });
};

export const getAllOrganizationSettingsQueryKey = (options: Options<GetAllOrganizationSettingsData>) => createQueryKey('getAllOrganizationSettings', options);

/**
 * List settings
 * List all organization settings.
 */
export const getAllOrganizationSettingsOptions = (options: Options<GetAllOrganizationSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllOrganizationSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllOrganizationSettingsQueryKey(options)
    });
};

export const setOrganizationSettingQueryKey = (options: Options<SetOrganizationSettingData>) => createQueryKey('setOrganizationSetting', options);

/**
 * Set organization setting
 * Create or update an organization setting.
 */
export const setOrganizationSettingOptions = (options: Options<SetOrganizationSettingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await setOrganizationSetting({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: setOrganizationSettingQueryKey(options)
    });
};

/**
 * Set organization setting
 * Create or update an organization setting.
 */
export const setOrganizationSettingMutation = (options?: Partial<Options<SetOrganizationSettingData>>): UseMutationOptions<SetOrganizationSettingResponse, DefaultError, Options<SetOrganizationSettingData>> => {
    const mutationOptions: UseMutationOptions<SetOrganizationSettingResponse, DefaultError, Options<SetOrganizationSettingData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await setOrganizationSetting({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const applyDataRetentionQueryKey = (options: Options<ApplyDataRetentionData>) => createQueryKey('applyDataRetention', options);

/**
 * Apply data retention
 * Run data retention worker once for the organization.
 */
export const applyDataRetentionOptions = (options: Options<ApplyDataRetentionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await applyDataRetention({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: applyDataRetentionQueryKey(options)
    });
};

/**
 * Apply data retention
 * Run data retention worker once for the organization.
 */
export const applyDataRetentionMutation = (options?: Partial<Options<ApplyDataRetentionData>>): UseMutationOptions<ApplyDataRetentionResponse, DefaultError, Options<ApplyDataRetentionData>> => {
    const mutationOptions: UseMutationOptions<ApplyDataRetentionResponse, DefaultError, Options<ApplyDataRetentionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await applyDataRetention({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrgEffectiveSettingsQueryKey = (options: Options<GetOrgEffectiveSettingsData>) => createQueryKey('getOrgEffectiveSettings', options);

/**
 * Effective org settings
 * Get effective organization settings (defaults plus overrides).
 */
export const getOrgEffectiveSettingsOptions = (options: Options<GetOrgEffectiveSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrgEffectiveSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrgEffectiveSettingsQueryKey(options)
    });
};

/**
 * Delete setting
 * Delete an organization setting.
 */
export const deleteOrganizationSettingMutation = (options?: Partial<Options<DeleteOrganizationSettingData>>): UseMutationOptions<DeleteOrganizationSettingResponse, DefaultError, Options<DeleteOrganizationSettingData>> => {
    const mutationOptions: UseMutationOptions<DeleteOrganizationSettingResponse, DefaultError, Options<DeleteOrganizationSettingData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteOrganizationSetting({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationSettingQueryKey = (options: Options<GetOrganizationSettingData>) => createQueryKey('getOrganizationSetting', options);

/**
 * Get setting
 * Get a single organization setting value.
 */
export const getOrganizationSettingOptions = (options: Options<GetOrganizationSettingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrganizationSetting({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationSettingQueryKey(options)
    });
};

export const checkBreachesQueryKey = (options: Options<CheckBreachesData>) => createQueryKey('checkBreaches', options);

/**
 * Check SLA breaches
 * Evaluate tickets against SLA policies and mark breaches.
 */
export const checkBreachesOptions = (options: Options<CheckBreachesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await checkBreaches({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: checkBreachesQueryKey(options)
    });
};

/**
 * Check SLA breaches
 * Evaluate tickets against SLA policies and mark breaches.
 */
export const checkBreachesMutation = (options?: Partial<Options<CheckBreachesData>>): UseMutationOptions<CheckBreachesResponse, DefaultError, Options<CheckBreachesData>> => {
    const mutationOptions: UseMutationOptions<CheckBreachesResponse, DefaultError, Options<CheckBreachesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await checkBreaches({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const countdownSseQueryKey = (options: Options<CountdownSseData>) => createQueryKey('countdownSse', options);

/**
 * SLA countdown stream
 * Server-Sent Events (SSE) stream of remaining time for first response and resolution.
 */
export const countdownSseOptions = (options: Options<CountdownSseData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await countdownSse({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: countdownSseQueryKey(options)
    });
};

export const listPoliciesQueryKey = (options: Options<ListPoliciesData>) => createQueryKey('listPolicies', options);

/**
 * List SLA policies
 * List SLA policies for an organization.
 */
export const listPoliciesOptions = (options: Options<ListPoliciesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listPolicies({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listPoliciesQueryKey(options)
    });
};

export const createPolicyQueryKey = (options: Options<CreatePolicyData>) => createQueryKey('createPolicy', options);

/**
 * Create SLA policy
 * Create an SLA policy with conditions and targets.
 */
export const createPolicyOptions = (options: Options<CreatePolicyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createPolicy({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createPolicyQueryKey(options)
    });
};

/**
 * Create SLA policy
 * Create an SLA policy with conditions and targets.
 */
export const createPolicyMutation = (options?: Partial<Options<CreatePolicyData>>): UseMutationOptions<CreatePolicyResponse, DefaultError, Options<CreatePolicyData>> => {
    const mutationOptions: UseMutationOptions<CreatePolicyResponse, DefaultError, Options<CreatePolicyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createPolicy({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update SLA policy
 * Update SLA policy fields such as targets or activation.
 */
export const updatePolicyMutation = (options?: Partial<Options<UpdatePolicyData>>): UseMutationOptions<UpdatePolicyResponse, DefaultError, Options<UpdatePolicyData>> => {
    const mutationOptions: UseMutationOptions<UpdatePolicyResponse, DefaultError, Options<UpdatePolicyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updatePolicy({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listSurveysQueryKey = (options: Options<ListSurveysData>) => createQueryKey('listSurveys', options);

/**
 * List CSAT surveys
 * List CSAT surveys with filters and pagination.
 */
export const listSurveysOptions = (options: Options<ListSurveysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSurveys({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSurveysQueryKey(options)
    });
};

export const listSurveysInfiniteQueryKey = (options: Options<ListSurveysData>): QueryKey<Options<ListSurveysData>> => createQueryKey('listSurveys', options, true);

/**
 * List CSAT surveys
 * List CSAT surveys with filters and pagination.
 */
export const listSurveysInfiniteOptions = (options: Options<ListSurveysData>) => {
    return infiniteQueryOptions<ListSurveysResponse, DefaultError, InfiniteData<ListSurveysResponse>, QueryKey<Options<ListSurveysData>>, number | Pick<QueryKey<Options<ListSurveysData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListSurveysData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listSurveys({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSurveysInfiniteQueryKey(options)
    });
};

export const submitSurveyQueryKey = (options: Options<SubmitSurveyData>) => createQueryKey('submitSurvey', options);

/**
 * Submit CSAT survey
 * Submit a customer satisfaction survey for a ticket.
 */
export const submitSurveyOptions = (options: Options<SubmitSurveyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await submitSurvey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: submitSurveyQueryKey(options)
    });
};

/**
 * Submit CSAT survey
 * Submit a customer satisfaction survey for a ticket.
 */
export const submitSurveyMutation = (options?: Partial<Options<SubmitSurveyData>>): UseMutationOptions<SubmitSurveyResponse, DefaultError, Options<SubmitSurveyData>> => {
    const mutationOptions: UseMutationOptions<SubmitSurveyResponse, DefaultError, Options<SubmitSurveyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await submitSurvey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCsatAnalyticsQueryKey = (options: Options<GetCsatAnalyticsData>) => createQueryKey('getCsatAnalytics', options);

/**
 * Get CSAT analytics
 * Retrieve aggregated CSAT analytics for the organization.
 */
export const getCsatAnalyticsOptions = (options: Options<GetCsatAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCsatAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCsatAnalyticsQueryKey(options)
    });
};

/**
 * Delete CSAT survey
 * Delete a CSAT survey by ID.
 */
export const deleteSurveyMutation = (options?: Partial<Options<DeleteSurveyData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteSurveyData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteSurveyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteSurvey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSurveyQueryKey = (options: Options<GetSurveyData>) => createQueryKey('getSurvey', options);

/**
 * Get CSAT survey
 * Retrieve a single CSAT survey by ID.
 */
export const getSurveyOptions = (options: Options<GetSurveyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSurvey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSurveyQueryKey(options)
    });
};

/**
 * Update CSAT survey
 * Update score and/or comment for a CSAT survey.
 */
export const updateSurveyMutation = (options?: Partial<Options<UpdateSurveyData>>): UseMutationOptions<UpdateSurveyResponse, DefaultError, Options<UpdateSurveyData>> => {
    const mutationOptions: UseMutationOptions<UpdateSurveyResponse, DefaultError, Options<UpdateSurveyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateSurvey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTagsQueryKey = (options: Options<ListTagsData>) => createQueryKey('listTags', options);

/**
 * List tags
 * List tags for the organization with pagination.
 */
export const listTagsOptions = (options: Options<ListTagsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTags({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTagsQueryKey(options)
    });
};

export const listTagsInfiniteQueryKey = (options: Options<ListTagsData>): QueryKey<Options<ListTagsData>> => createQueryKey('listTags', options, true);

/**
 * List tags
 * List tags for the organization with pagination.
 */
export const listTagsInfiniteOptions = (options: Options<ListTagsData>) => {
    return infiniteQueryOptions<ListTagsResponse, DefaultError, InfiniteData<ListTagsResponse>, QueryKey<Options<ListTagsData>>, number | Pick<QueryKey<Options<ListTagsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListTagsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listTags({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTagsInfiniteQueryKey(options)
    });
};

export const createTagQueryKey = (options: Options<CreateTagData>) => createQueryKey('createTag', options);

/**
 * Create a tag
 * Create a new tag within the organization. Requires MANAGE_TAGS.
 */
export const createTagOptions = (options: Options<CreateTagData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createTag({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createTagQueryKey(options)
    });
};

/**
 * Create a tag
 * Create a new tag within the organization. Requires MANAGE_TAGS.
 */
export const createTagMutation = (options?: Partial<Options<CreateTagData>>): UseMutationOptions<CreateTagResponse, DefaultError, Options<CreateTagData>> => {
    const mutationOptions: UseMutationOptions<CreateTagResponse, DefaultError, Options<CreateTagData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createTag({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPopularTagsQueryKey = (options: Options<GetPopularTagsData>) => createQueryKey('getPopularTags', options);

/**
 * Popular tags
 * List the most-used tags in the organization.
 */
export const getPopularTagsOptions = (options: Options<GetPopularTagsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPopularTags({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPopularTagsQueryKey(options)
    });
};

/**
 * Delete a tag
 * Delete a tag and remove its associations. Requires MANAGE_TAGS.
 */
export const deleteTagMutation = (options?: Partial<Options<DeleteTagData>>): UseMutationOptions<DeleteTagResponse, DefaultError, Options<DeleteTagData>> => {
    const mutationOptions: UseMutationOptions<DeleteTagResponse, DefaultError, Options<DeleteTagData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteTag({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTagQueryKey = (options: Options<GetTagData>) => createQueryKey('getTag', options);

/**
 * Get a tag
 * Retrieve a tag by ID including computed ticket count.
 */
export const getTagOptions = (options: Options<GetTagData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTag({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagQueryKey(options)
    });
};

/**
 * Update a tag
 * Update tag name or color. Requires MANAGE_TAGS.
 */
export const updateTagMutation = (options?: Partial<Options<UpdateTagData>>): UseMutationOptions<UpdateTagResponse, DefaultError, Options<UpdateTagData>> => {
    const mutationOptions: UseMutationOptions<UpdateTagResponse, DefaultError, Options<UpdateTagData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTag({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTagWithTicketsQueryKey = (options: Options<GetTagWithTicketsData>) => createQueryKey('getTagWithTickets', options);

/**
 * Get tag with tickets
 * Get a tag and a paginated list of associated tickets.
 */
export const getTagWithTicketsOptions = (options: Options<GetTagWithTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTagWithTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagWithTicketsQueryKey(options)
    });
};

export const getTagWithTicketsInfiniteQueryKey = (options: Options<GetTagWithTicketsData>): QueryKey<Options<GetTagWithTicketsData>> => createQueryKey('getTagWithTickets', options, true);

/**
 * Get tag with tickets
 * Get a tag and a paginated list of associated tickets.
 */
export const getTagWithTicketsInfiniteOptions = (options: Options<GetTagWithTicketsData>) => {
    return infiniteQueryOptions<GetTagWithTicketsResponse, DefaultError, InfiniteData<GetTagWithTicketsResponse>, QueryKey<Options<GetTagWithTicketsData>>, number | Pick<QueryKey<Options<GetTagWithTicketsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetTagWithTicketsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getTagWithTickets({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagWithTicketsInfiniteQueryKey(options)
    });
};

export const listTeamsQueryKey = (options: Options<ListTeamsData>) => createQueryKey('listTeams', options);

/**
 * List teams
 * List teams in the organization.
 */
export const listTeamsOptions = (options: Options<ListTeamsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTeams({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTeamsQueryKey(options)
    });
};

export const createTeamQueryKey = (options: Options<CreateTeamData>) => createQueryKey('createTeam', options);

/**
 * Create team
 * Create a team within the organization.
 */
export const createTeamOptions = (options: Options<CreateTeamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createTeam({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createTeamQueryKey(options)
    });
};

/**
 * Create team
 * Create a team within the organization.
 */
export const createTeamMutation = (options?: Partial<Options<CreateTeamData>>): UseMutationOptions<CreateTeamResponse, DefaultError, Options<CreateTeamData>> => {
    const mutationOptions: UseMutationOptions<CreateTeamResponse, DefaultError, Options<CreateTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update team
 * Update team name and description.
 */
export const updateTeamMutation = (options?: Partial<Options<UpdateTeamData>>): UseMutationOptions<UpdateTeamResponse, DefaultError, Options<UpdateTeamData>> => {
    const mutationOptions: UseMutationOptions<UpdateTeamResponse, DefaultError, Options<UpdateTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listMembersQueryKey = (options: Options<ListMembersData>) => createQueryKey('listMembers', options);

/**
 * List team members
 * List members in a team.
 */
export const listMembersOptions = (options: Options<ListMembersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listMembers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMembersQueryKey(options)
    });
};

export const addMemberQueryKey = (options: Options<AddMemberData>) => createQueryKey('addMember', options);

/**
 * Add team member
 * Add a user to a team with a role.
 */
export const addMemberOptions = (options: Options<AddMemberData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addMember({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addMemberQueryKey(options)
    });
};

/**
 * Add team member
 * Add a user to a team with a role.
 */
export const addMemberMutation = (options?: Partial<Options<AddMemberData>>): UseMutationOptions<AddMemberResponse, DefaultError, Options<AddMemberData>> => {
    const mutationOptions: UseMutationOptions<AddMemberResponse, DefaultError, Options<AddMemberData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addMember({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove team member
 * Remove a user from a team.
 */
export const removeMember2Mutation = (options?: Partial<Options<RemoveMember2Data>>): UseMutationOptions<RemoveMember2Response, DefaultError, Options<RemoveMember2Data>> => {
    const mutationOptions: UseMutationOptions<RemoveMember2Response, DefaultError, Options<RemoveMember2Data>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeMember2({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTicketsQueryKey = (options: Options<ListTicketsData>) => createQueryKey('listTickets', options);

/**
 * List tickets with filtering
 * Retrieves a paginated list of tickets with optional filtering by status, priority, assignment, creator, and tags. Results are ordered by creation date (newest first).
 */
export const listTicketsOptions = (options: Options<ListTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTicketsQueryKey(options)
    });
};

export const listTicketsInfiniteQueryKey = (options: Options<ListTicketsData>): QueryKey<Options<ListTicketsData>> => createQueryKey('listTickets', options, true);

/**
 * List tickets with filtering
 * Retrieves a paginated list of tickets with optional filtering by status, priority, assignment, creator, and tags. Results are ordered by creation date (newest first).
 */
export const listTicketsInfiniteOptions = (options: Options<ListTicketsData>) => {
    return infiniteQueryOptions<ListTicketsResponse, ListTicketsError, InfiniteData<ListTicketsResponse>, QueryKey<Options<ListTicketsData>>, number | Pick<QueryKey<Options<ListTicketsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListTicketsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listTickets({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTicketsInfiniteQueryKey(options)
    });
};

export const createTicketQueryKey = (options: Options<CreateTicketData>) => createQueryKey('createTicket', options);

/**
 * Create a new support ticket
 * Creates a new support ticket in the specified organization. The ticket will be assigned to the authenticated user as the creator and can optionally be assigned to another team member.
 */
export const createTicketOptions = (options: Options<CreateTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createTicketQueryKey(options)
    });
};

/**
 * Create a new support ticket
 * Creates a new support ticket in the specified organization. The ticket will be assigned to the authenticated user as the creator and can optionally be assigned to another team member.
 */
export const createTicketMutation = (options?: Partial<Options<CreateTicketData>>): UseMutationOptions<CreateTicketResponse, CreateTicketError, Options<CreateTicketData>> => {
    const mutationOptions: UseMutationOptions<CreateTicketResponse, CreateTicketError, Options<CreateTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkUpdateTicketsQueryKey = (options: Options<BulkUpdateTicketsData>) => createQueryKey('bulkUpdateTickets', options);

/**
 * Bulk update tickets
 */
export const bulkUpdateTicketsOptions = (options: Options<BulkUpdateTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await bulkUpdateTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: bulkUpdateTicketsQueryKey(options)
    });
};

/**
 * Bulk update tickets
 */
export const bulkUpdateTicketsMutation = (options?: Partial<Options<BulkUpdateTicketsData>>): UseMutationOptions<unknown, DefaultError, Options<BulkUpdateTicketsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<BulkUpdateTicketsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkUpdateTickets({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const mergeTicketsQueryKey = (options: Options<MergeTicketsData>) => createQueryKey('mergeTickets', options);

/**
 * Merge two tickets
 */
export const mergeTicketsOptions = (options: Options<MergeTicketsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await mergeTickets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: mergeTicketsQueryKey(options)
    });
};

/**
 * Merge two tickets
 */
export const mergeTicketsMutation = (options?: Partial<Options<MergeTicketsData>>): UseMutationOptions<unknown, DefaultError, Options<MergeTicketsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<MergeTicketsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await mergeTickets({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const splitTicketQueryKey = (options: Options<SplitTicketData>) => createQueryKey('splitTicket', options);

/**
 * Split a ticket's selected messages into a new ticket
 */
export const splitTicketOptions = (options: Options<SplitTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await splitTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: splitTicketQueryKey(options)
    });
};

/**
 * Split a ticket's selected messages into a new ticket
 */
export const splitTicketMutation = (options?: Partial<Options<SplitTicketData>>): UseMutationOptions<SplitTicketResponse, DefaultError, Options<SplitTicketData>> => {
    const mutationOptions: UseMutationOptions<SplitTicketResponse, DefaultError, Options<SplitTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await splitTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listSavedViewsQueryKey = (options: Options<ListSavedViewsData>) => createQueryKey('listSavedViews', options);

/**
 * List saved views
 */
export const listSavedViewsOptions = (options: Options<ListSavedViewsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSavedViews({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSavedViewsQueryKey(options)
    });
};

export const createSavedViewQueryKey = (options: Options<CreateSavedViewData>) => createQueryKey('createSavedView', options);

/**
 * Create a saved view
 */
export const createSavedViewOptions = (options: Options<CreateSavedViewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createSavedView({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createSavedViewQueryKey(options)
    });
};

/**
 * Create a saved view
 */
export const createSavedViewMutation = (options?: Partial<Options<CreateSavedViewData>>): UseMutationOptions<CreateSavedViewResponse, DefaultError, Options<CreateSavedViewData>> => {
    const mutationOptions: UseMutationOptions<CreateSavedViewResponse, DefaultError, Options<CreateSavedViewData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createSavedView({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteTicketMutation = (options?: Partial<Options<DeleteTicketData>>): UseMutationOptions<DeleteTicketResponse, DeleteTicketError, Options<DeleteTicketData>> => {
    const mutationOptions: UseMutationOptions<DeleteTicketResponse, DeleteTicketError, Options<DeleteTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTicketQueryKey = (options: Options<GetTicketData>) => createQueryKey('getTicket', options);

/**
 * Get ticket details
 * Retrieves detailed information about a specific ticket including its current status, assignment, tags, and metadata.
 */
export const getTicketOptions = (options: Options<GetTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTicketQueryKey(options)
    });
};

export const updateTicketMutation = (options?: Partial<Options<UpdateTicketData>>): UseMutationOptions<UpdateTicketResponse, UpdateTicketError, Options<UpdateTicketData>> => {
    const mutationOptions: UseMutationOptions<UpdateTicketResponse, UpdateTicketError, Options<UpdateTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const assignTicketTeamQueryKey = (options: Options<AssignTicketTeamData>) => createQueryKey('assignTicketTeam', options);

export const assignTicketTeamOptions = (options: Options<AssignTicketTeamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignTicketTeam({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignTicketTeamQueryKey(options)
    });
};

export const assignTicketTeamMutation = (options?: Partial<Options<AssignTicketTeamData>>): UseMutationOptions<AssignTicketTeamResponse, AssignTicketTeamError, Options<AssignTicketTeamData>> => {
    const mutationOptions: UseMutationOptions<AssignTicketTeamResponse, AssignTicketTeamError, Options<AssignTicketTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await assignTicketTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const clearTicketTeamAssignmentMutation = (options?: Partial<Options<ClearTicketTeamAssignmentData>>): UseMutationOptions<ClearTicketTeamAssignmentResponse, DefaultError, Options<ClearTicketTeamAssignmentData>> => {
    const mutationOptions: UseMutationOptions<ClearTicketTeamAssignmentResponse, DefaultError, Options<ClearTicketTeamAssignmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await clearTicketTeamAssignment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTicketTeamAssignmentQueryKey = (options: Options<GetTicketTeamAssignmentData>) => createQueryKey('getTicketTeamAssignment', options);

export const getTicketTeamAssignmentOptions = (options: Options<GetTicketTeamAssignmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTicketTeamAssignment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTicketTeamAssignmentQueryKey(options)
    });
};

/**
 * Delete current user's draft for a ticket
 */
export const deleteDraftMutation = (options?: Partial<Options<DeleteDraftData>>): UseMutationOptions<DeleteDraftResponse, DefaultError, Options<DeleteDraftData>> => {
    const mutationOptions: UseMutationOptions<DeleteDraftResponse, DefaultError, Options<DeleteDraftData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteDraft({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDraftQueryKey = (options: Options<GetDraftData>) => createQueryKey('getDraft', options);

/**
 * Get current user's draft for a ticket
 */
export const getDraftOptions = (options: Options<GetDraftData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDraft({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDraftQueryKey(options)
    });
};

export const upsertDraftQueryKey = (options: Options<UpsertDraftData>) => createQueryKey('upsertDraft', options);

/**
 * Create or update a draft for a ticket
 */
export const upsertDraftOptions = (options: Options<UpsertDraftData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await upsertDraft({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: upsertDraftQueryKey(options)
    });
};

/**
 * Create or update a draft for a ticket
 */
export const upsertDraftMutation = (options?: Partial<Options<UpsertDraftData>>): UseMutationOptions<UpsertDraftResponse, DefaultError, Options<UpsertDraftData>> => {
    const mutationOptions: UseMutationOptions<UpsertDraftResponse, DefaultError, Options<UpsertDraftData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await upsertDraft({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const aiGenerateDraftQueryKey = (options: Options<AiGenerateDraftData>) => createQueryKey('aiGenerateDraft', options);

/**
 * Generate AI draft reply for a ticket
 */
export const aiGenerateDraftOptions = (options: Options<AiGenerateDraftData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await aiGenerateDraft({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: aiGenerateDraftQueryKey(options)
    });
};

/**
 * Generate AI draft reply for a ticket
 */
export const aiGenerateDraftMutation = (options?: Partial<Options<AiGenerateDraftData>>): UseMutationOptions<AiGenerateDraftResponse, DefaultError, Options<AiGenerateDraftData>> => {
    const mutationOptions: UseMutationOptions<AiGenerateDraftResponse, DefaultError, Options<AiGenerateDraftData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await aiGenerateDraft({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTicketHistoryQueryKey = (options: Options<GetTicketHistoryData>) => createQueryKey('getTicketHistory', options);

/**
 * Get ticket history
 * Requires permission: VIEW_ALL_TICKETS
 */
export const getTicketHistoryOptions = (options: Options<GetTicketHistoryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTicketHistory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTicketHistoryQueryKey(options)
    });
};

export const releaseTicketLockMutation = (options?: Partial<Options<ReleaseTicketLockData>>): UseMutationOptions<ReleaseTicketLockResponse, DefaultError, Options<ReleaseTicketLockData>> => {
    const mutationOptions: UseMutationOptions<ReleaseTicketLockResponse, DefaultError, Options<ReleaseTicketLockData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await releaseTicketLock({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lockTicketQueryKey = (options: Options<LockTicketData>) => createQueryKey('lockTicket', options);

export const lockTicketOptions = (options: Options<LockTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lockTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lockTicketQueryKey(options)
    });
};

export const lockTicketMutation = (options?: Partial<Options<LockTicketData>>): UseMutationOptions<unknown, DefaultError, Options<LockTicketData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<LockTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lockTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const takeoverTicketLockQueryKey = (options: Options<TakeoverTicketLockData>) => createQueryKey('takeoverTicketLock', options);

export const takeoverTicketLockOptions = (options: Options<TakeoverTicketLockData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await takeoverTicketLock({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: takeoverTicketLockQueryKey(options)
    });
};

export const takeoverTicketLockMutation = (options?: Partial<Options<TakeoverTicketLockData>>): UseMutationOptions<unknown, DefaultError, Options<TakeoverTicketLockData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<TakeoverTicketLockData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await takeoverTicketLock({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTicketMessagesQueryKey = (options: Options<ListTicketMessagesData>) => createQueryKey('listTicketMessages', options);

export const listTicketMessagesOptions = (options: Options<ListTicketMessagesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTicketMessages({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTicketMessagesQueryKey(options)
    });
};

export const listTicketMessagesInfiniteQueryKey = (options: Options<ListTicketMessagesData>): QueryKey<Options<ListTicketMessagesData>> => createQueryKey('listTicketMessages', options, true);

export const listTicketMessagesInfiniteOptions = (options: Options<ListTicketMessagesData>) => {
    return infiniteQueryOptions<ListTicketMessagesResponse, ListTicketMessagesError, InfiniteData<ListTicketMessagesResponse>, QueryKey<Options<ListTicketMessagesData>>, number | Pick<QueryKey<Options<ListTicketMessagesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListTicketMessagesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listTicketMessages({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTicketMessagesInfiniteQueryKey(options)
    });
};

export const createMessageQueryKey = (options: Options<CreateMessageData>) => createQueryKey('createMessage', options);

export const createMessageOptions = (options: Options<CreateMessageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createMessage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createMessageQueryKey(options)
    });
};

export const createMessageMutation = (options?: Partial<Options<CreateMessageData>>): UseMutationOptions<CreateMessageResponse, CreateMessageError, Options<CreateMessageData>> => {
    const mutationOptions: UseMutationOptions<CreateMessageResponse, CreateMessageError, Options<CreateMessageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createMessage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMessageCountQueryKey = (options: Options<GetMessageCountData>) => createQueryKey('getMessageCount', options);

export const getMessageCountOptions = (options: Options<GetMessageCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMessageCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMessageCountQueryKey(options)
    });
};

export const createInternalNoteQueryKey = (options: Options<CreateInternalNoteData>) => createQueryKey('createInternalNote', options);

export const createInternalNoteOptions = (options: Options<CreateInternalNoteData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createInternalNote({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createInternalNoteQueryKey(options)
    });
};

export const createInternalNoteMutation = (options?: Partial<Options<CreateInternalNoteData>>): UseMutationOptions<CreateInternalNoteResponse, DefaultError, Options<CreateInternalNoteData>> => {
    const mutationOptions: UseMutationOptions<CreateInternalNoteResponse, DefaultError, Options<CreateInternalNoteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createInternalNote({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLatestMessageQueryKey = (options: Options<GetLatestMessageData>) => createQueryKey('getLatestMessage', options);

export const getLatestMessageOptions = (options: Options<GetLatestMessageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLatestMessage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLatestMessageQueryKey(options)
    });
};

export const searchMessagesQueryKey = (options: Options<SearchMessagesData>) => createQueryKey('searchMessages', options);

export const searchMessagesOptions = (options: Options<SearchMessagesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await searchMessages({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: searchMessagesQueryKey(options)
    });
};

export const searchMessagesInfiniteQueryKey = (options: Options<SearchMessagesData>): QueryKey<Options<SearchMessagesData>> => createQueryKey('searchMessages', options, true);

export const searchMessagesInfiniteOptions = (options: Options<SearchMessagesData>) => {
    return infiniteQueryOptions<SearchMessagesResponse, SearchMessagesError, InfiniteData<SearchMessagesResponse>, QueryKey<Options<SearchMessagesData>>, number | Pick<QueryKey<Options<SearchMessagesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<SearchMessagesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await searchMessages({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: searchMessagesInfiniteQueryKey(options)
    });
};

export const listMessageAttachmentsQueryKey = (options: Options<ListMessageAttachmentsData>) => createQueryKey('listMessageAttachments', options);

export const listMessageAttachmentsOptions = (options: Options<ListMessageAttachmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listMessageAttachments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMessageAttachmentsQueryKey(options)
    });
};

export const uploadAttachmentsQueryKey = (options: Options<UploadAttachmentsData>) => createQueryKey('uploadAttachments', options);

export const uploadAttachmentsOptions = (options: Options<UploadAttachmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await uploadAttachments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: uploadAttachmentsQueryKey(options)
    });
};

export const uploadAttachmentsMutation = (options?: Partial<Options<UploadAttachmentsData>>): UseMutationOptions<UploadAttachmentsResponse, UploadAttachmentsError, Options<UploadAttachmentsData>> => {
    const mutationOptions: UseMutationOptions<UploadAttachmentsResponse, UploadAttachmentsError, Options<UploadAttachmentsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await uploadAttachments({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteAttachmentMutation = (options?: Partial<Options<DeleteAttachmentData>>): UseMutationOptions<DeleteAttachmentResponse, DeleteAttachmentError, Options<DeleteAttachmentData>> => {
    const mutationOptions: UseMutationOptions<DeleteAttachmentResponse, DeleteAttachmentError, Options<DeleteAttachmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteAttachment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeTagsFromTicketMutation = (options?: Partial<Options<RemoveTagsFromTicketData>>): UseMutationOptions<RemoveTagsFromTicketResponse, RemoveTagsFromTicketError, Options<RemoveTagsFromTicketData>> => {
    const mutationOptions: UseMutationOptions<RemoveTagsFromTicketResponse, RemoveTagsFromTicketError, Options<RemoveTagsFromTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeTagsFromTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addTagsToTicketQueryKey = (options: Options<AddTagsToTicketData>) => createQueryKey('addTagsToTicket', options);

export const addTagsToTicketOptions = (options: Options<AddTagsToTicketData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addTagsToTicket({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addTagsToTicketQueryKey(options)
    });
};

export const addTagsToTicketMutation = (options?: Partial<Options<AddTagsToTicketData>>): UseMutationOptions<unknown, AddTagsToTicketError, Options<AddTagsToTicketData>> => {
    const mutationOptions: UseMutationOptions<unknown, AddTagsToTicketError, Options<AddTagsToTicketData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addTagsToTicket({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTypingQueryKey = (options: Options<ListTypingData>) => createQueryKey('listTyping', options);

/**
 * List users typing on a ticket
 * List user IDs of agents currently typing on the specified ticket.
 */
export const listTypingOptions = (options: Options<ListTypingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTyping({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTypingQueryKey(options)
    });
};

export const typingUpdateQueryKey = (options: Options<TypingUpdateData>) => createQueryKey('typingUpdate', options);

/**
 * Set typing indicator
 * Set or clear the caller's typing state for a specific ticket.
 */
export const typingUpdateOptions = (options: Options<TypingUpdateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await typingUpdate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: typingUpdateQueryKey(options)
    });
};

/**
 * Set typing indicator
 * Set or clear the caller's typing state for a specific ticket.
 */
export const typingUpdateMutation = (options?: Partial<Options<TypingUpdateData>>): UseMutationOptions<TypingUpdateResponse, DefaultError, Options<TypingUpdateData>> => {
    const mutationOptions: UseMutationOptions<TypingUpdateResponse, DefaultError, Options<TypingUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await typingUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTicketWatchersQueryKey = (options: Options<ListTicketWatchersData>) => createQueryKey('listTicketWatchers', options);

export const listTicketWatchersOptions = (options: Options<ListTicketWatchersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTicketWatchers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTicketWatchersQueryKey(options)
    });
};

export const addTicketWatcherQueryKey = (options: Options<AddTicketWatcherData>) => createQueryKey('addTicketWatcher', options);

export const addTicketWatcherOptions = (options: Options<AddTicketWatcherData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addTicketWatcher({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addTicketWatcherQueryKey(options)
    });
};

export const addTicketWatcherMutation = (options?: Partial<Options<AddTicketWatcherData>>): UseMutationOptions<AddTicketWatcherResponse, DefaultError, Options<AddTicketWatcherData>> => {
    const mutationOptions: UseMutationOptions<AddTicketWatcherResponse, DefaultError, Options<AddTicketWatcherData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addTicketWatcher({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeTicketWatcherMutation = (options?: Partial<Options<RemoveTicketWatcherData>>): UseMutationOptions<RemoveTicketWatcherResponse, DefaultError, Options<RemoveTicketWatcherData>> => {
    const mutationOptions: UseMutationOptions<RemoveTicketWatcherResponse, DefaultError, Options<RemoveTicketWatcherData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeTicketWatcher({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listCustomFieldsQueryKey = (options: Options<ListCustomFieldsData>) => createQueryKey('listCustomFields', options);

/**
 * List user custom fields
 * List all defined user custom fields for the organization.
 */
export const listCustomFieldsOptions = (options: Options<ListCustomFieldsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listCustomFields({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listCustomFieldsQueryKey(options)
    });
};

export const createCustomFieldQueryKey = (options: Options<CreateCustomFieldData>) => createQueryKey('createCustomField', options);

/**
 * Create a user custom field
 * Define a per-organization custom field for users (e.g., plan, region).
 */
export const createCustomFieldOptions = (options: Options<CreateCustomFieldData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createCustomField({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createCustomFieldQueryKey(options)
    });
};

/**
 * Create a user custom field
 * Define a per-organization custom field for users (e.g., plan, region).
 */
export const createCustomFieldMutation = (options?: Partial<Options<CreateCustomFieldData>>): UseMutationOptions<CreateCustomFieldResponse, DefaultError, Options<CreateCustomFieldData>> => {
    const mutationOptions: UseMutationOptions<CreateCustomFieldResponse, DefaultError, Options<CreateCustomFieldData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createCustomField({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a user custom field
 * Remove a custom field definition and all associated values.
 */
export const deleteCustomFieldMutation = (options?: Partial<Options<DeleteCustomFieldData>>): UseMutationOptions<DeleteCustomFieldResponse, DefaultError, Options<DeleteCustomFieldData>> => {
    const mutationOptions: UseMutationOptions<DeleteCustomFieldResponse, DefaultError, Options<DeleteCustomFieldData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCustomField({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listSegmentsQueryKey = (options: Options<ListSegmentsData>) => createQueryKey('listSegments', options);

/**
 * List user segments
 * List all segments defined for the organization.
 */
export const listSegmentsOptions = (options: Options<ListSegmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSegments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSegmentsQueryKey(options)
    });
};

export const createSegmentQueryKey = (options: Options<CreateSegmentData>) => createQueryKey('createSegment', options);

/**
 * Create a user segment
 * Create a segment of users based on custom field rules.
 */
export const createSegmentOptions = (options: Options<CreateSegmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createSegment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createSegmentQueryKey(options)
    });
};

/**
 * Create a user segment
 * Create a segment of users based on custom field rules.
 */
export const createSegmentMutation = (options?: Partial<Options<CreateSegmentData>>): UseMutationOptions<CreateSegmentResponse, DefaultError, Options<CreateSegmentData>> => {
    const mutationOptions: UseMutationOptions<CreateSegmentResponse, DefaultError, Options<CreateSegmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createSegment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a user segment
 * Remove a user segment.
 */
export const deleteSegmentMutation = (options?: Partial<Options<DeleteSegmentData>>): UseMutationOptions<DeleteSegmentResponse, DefaultError, Options<DeleteSegmentData>> => {
    const mutationOptions: UseMutationOptions<DeleteSegmentResponse, DefaultError, Options<DeleteSegmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteSegment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a user segment
 * Update a segment's name and/or rules.
 */
export const updateSegmentMutation = (options?: Partial<Options<UpdateSegmentData>>): UseMutationOptions<UpdateSegmentResponse, DefaultError, Options<UpdateSegmentData>> => {
    const mutationOptions: UseMutationOptions<UpdateSegmentResponse, DefaultError, Options<UpdateSegmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateSegment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const evaluateSegmentQueryKey = (options: Options<EvaluateSegmentData>) => createQueryKey('evaluateSegment', options);

/**
 * Evaluate a user segment
 * Evaluate and return the list of user IDs matching the segment rules.
 */
export const evaluateSegmentOptions = (options: Options<EvaluateSegmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await evaluateSegment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: evaluateSegmentQueryKey(options)
    });
};

/**
 * Evaluate a user segment
 * Evaluate and return the list of user IDs matching the segment rules.
 */
export const evaluateSegmentMutation = (options?: Partial<Options<EvaluateSegmentData>>): UseMutationOptions<EvaluateSegmentResponse2, DefaultError, Options<EvaluateSegmentData>> => {
    const mutationOptions: UseMutationOptions<EvaluateSegmentResponse2, DefaultError, Options<EvaluateSegmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await evaluateSegment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserCustomFieldsQueryKey = (options: Options<GetUserCustomFieldsData>) => createQueryKey('getUserCustomFields', options);

/**
 * Get a user's custom field values
 * Retrieve the custom field values for a specific user in the organization.
 */
export const getUserCustomFieldsOptions = (options: Options<GetUserCustomFieldsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserCustomFields({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserCustomFieldsQueryKey(options)
    });
};

/**
 * Set a user's custom field values
 * Create or update custom field values for a specific user.
 */
export const setUserCustomFieldsMutation = (options?: Partial<Options<SetUserCustomFieldsData>>): UseMutationOptions<SetUserCustomFieldsResponse, DefaultError, Options<SetUserCustomFieldsData>> => {
    const mutationOptions: UseMutationOptions<SetUserCustomFieldsResponse, DefaultError, Options<SetUserCustomFieldsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await setUserCustomFields({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listWebhooksQueryKey = (options: Options<ListWebhooksData>) => createQueryKey('listWebhooks', options);

/**
 * List webhooks
 * List webhooks for the organization with optional filters.
 */
export const listWebhooksOptions = (options: Options<ListWebhooksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listWebhooks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listWebhooksQueryKey(options)
    });
};

export const listWebhooksInfiniteQueryKey = (options: Options<ListWebhooksData>): QueryKey<Options<ListWebhooksData>> => createQueryKey('listWebhooks', options, true);

/**
 * List webhooks
 * List webhooks for the organization with optional filters.
 */
export const listWebhooksInfiniteOptions = (options: Options<ListWebhooksData>) => {
    return infiniteQueryOptions<ListWebhooksResponse, ListWebhooksError, InfiniteData<ListWebhooksResponse>, QueryKey<Options<ListWebhooksData>>, number | Pick<QueryKey<Options<ListWebhooksData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListWebhooksData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listWebhooks({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listWebhooksInfiniteQueryKey(options)
    });
};

export const createWebhookQueryKey = (options: Options<CreateWebhookData>) => createQueryKey('createWebhook', options);

/**
 * Create webhook
 * Create a webhook endpoint subscribed to specific events.
 */
export const createWebhookOptions = (options: Options<CreateWebhookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createWebhook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createWebhookQueryKey(options)
    });
};

/**
 * Create webhook
 * Create a webhook endpoint subscribed to specific events.
 */
export const createWebhookMutation = (options?: Partial<Options<CreateWebhookData>>): UseMutationOptions<CreateWebhookResponse, CreateWebhookError, Options<CreateWebhookData>> => {
    const mutationOptions: UseMutationOptions<CreateWebhookResponse, CreateWebhookError, Options<CreateWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listWebhookEventsQueryKey = (options: Options<ListWebhookEventsData>) => createQueryKey('listWebhookEvents', options);

/**
 * List supported webhook events
 * Get the list of event types that webhooks can subscribe to.
 */
export const listWebhookEventsOptions = (options: Options<ListWebhookEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listWebhookEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listWebhookEventsQueryKey(options)
    });
};

export const sendWebhooksQueryKey = (options: Options<SendWebhooksData>) => createQueryKey('sendWebhooks', options);

/**
 * Send webhooks for event
 * Trigger subscribed webhooks for the specified event with optional context.
 */
export const sendWebhooksOptions = (options: Options<SendWebhooksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await sendWebhooks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: sendWebhooksQueryKey(options)
    });
};

/**
 * Send webhooks for event
 * Trigger subscribed webhooks for the specified event with optional context.
 */
export const sendWebhooksMutation = (options?: Partial<Options<SendWebhooksData>>): UseMutationOptions<SendWebhooksResponse, DefaultError, Options<SendWebhooksData>> => {
    const mutationOptions: UseMutationOptions<SendWebhooksResponse, DefaultError, Options<SendWebhooksData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await sendWebhooks({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWebhookStatsQueryKey = (options: Options<GetWebhookStatsData>) => createQueryKey('getWebhookStats', options);

/**
 * Get webhook statistics
 * Retrieve aggregated statistics for webhooks in the organization.
 */
export const getWebhookStatsOptions = (options: Options<GetWebhookStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWebhookStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWebhookStatsQueryKey(options)
    });
};

/**
 * Delete webhook
 * Delete a webhook by ID.
 */
export const deleteWebhookMutation = (options?: Partial<Options<DeleteWebhookData>>): UseMutationOptions<DeleteWebhookResponse, DefaultError, Options<DeleteWebhookData>> => {
    const mutationOptions: UseMutationOptions<DeleteWebhookResponse, DefaultError, Options<DeleteWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWebhookQueryKey = (options: Options<GetWebhookData>) => createQueryKey('getWebhook', options);

/**
 * Get webhook
 * Retrieve a webhook by ID.
 */
export const getWebhookOptions = (options: Options<GetWebhookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWebhook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWebhookQueryKey(options)
    });
};

/**
 * Update webhook
 * Update webhook configuration.
 */
export const updateWebhookMutation = (options?: Partial<Options<UpdateWebhookData>>): UseMutationOptions<UpdateWebhookResponse, DefaultError, Options<UpdateWebhookData>> => {
    const mutationOptions: UseMutationOptions<UpdateWebhookResponse, DefaultError, Options<UpdateWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const testWebhookQueryKey = (options: Options<TestWebhookData>) => createQueryKey('testWebhook', options);

/**
 * Test webhook
 * Send a test event to the webhook and return the delivery result.
 */
export const testWebhookOptions = (options: Options<TestWebhookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testWebhook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testWebhookQueryKey(options)
    });
};

/**
 * Test webhook
 * Send a test event to the webhook and return the delivery result.
 */
export const testWebhookMutation = (options?: Partial<Options<TestWebhookData>>): UseMutationOptions<TestWebhookResponse, DefaultError, Options<TestWebhookData>> => {
    const mutationOptions: UseMutationOptions<TestWebhookResponse, DefaultError, Options<TestWebhookData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await testWebhook({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPermissionsCatalogQueryKey = (options?: Options<GetPermissionsCatalogData>) => createQueryKey('getPermissionsCatalog', options);

/**
 * Get permissions catalog
 * List permission keys and their bitmask values.
 */
export const getPermissionsCatalogOptions = (options?: Options<GetPermissionsCatalogData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPermissionsCatalog({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPermissionsCatalogQueryKey(options)
    });
};

export const listSessionsQueryKey = (options?: Options<ListSessionsData>) => createQueryKey('listSessions', options);

/**
 * List sessions
 * List active sessions for the authenticated user.
 */
export const listSessionsOptions = (options?: Options<ListSessionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSessions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSessionsQueryKey(options)
    });
};

export const cleanupExpiredSessionsQueryKey = (options?: Options<CleanupExpiredSessionsData>) => createQueryKey('cleanupExpiredSessions', options);

/**
 * Cleanup expired sessions
 * Delete expired sessions for all users.
 */
export const cleanupExpiredSessionsOptions = (options?: Options<CleanupExpiredSessionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await cleanupExpiredSessions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: cleanupExpiredSessionsQueryKey(options)
    });
};

/**
 * Cleanup expired sessions
 * Delete expired sessions for all users.
 */
export const cleanupExpiredSessionsMutation = (options?: Partial<Options<CleanupExpiredSessionsData>>): UseMutationOptions<unknown, DefaultError, Options<CleanupExpiredSessionsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CleanupExpiredSessionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await cleanupExpiredSessions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const revokeAllSessionsQueryKey = (options: Options<RevokeAllSessionsData>) => createQueryKey('revokeAllSessions', options);

/**
 * Revoke all sessions
 * Revoke all sessions for the user, optionally keeping current session.
 */
export const revokeAllSessionsOptions = (options: Options<RevokeAllSessionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await revokeAllSessions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: revokeAllSessionsQueryKey(options)
    });
};

/**
 * Revoke all sessions
 * Revoke all sessions for the user, optionally keeping current session.
 */
export const revokeAllSessionsMutation = (options?: Partial<Options<RevokeAllSessionsData>>): UseMutationOptions<unknown, DefaultError, Options<RevokeAllSessionsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RevokeAllSessionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await revokeAllSessions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSessionStatsQueryKey = (options?: Options<GetSessionStatsData>) => createQueryKey('getSessionStats', options);

/**
 * Get session stats
 * Retrieve total, active, and expired session counts.
 */
export const getSessionStatsOptions = (options?: Options<GetSessionStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSessionStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSessionStatsQueryKey(options)
    });
};

/**
 * Revoke session
 * Revoke a specific session.
 */
export const revokeSessionMutation = (options?: Partial<Options<RevokeSessionData>>): UseMutationOptions<unknown, DefaultError, Options<RevokeSessionData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RevokeSessionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await revokeSession({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSessionQueryKey = (options: Options<GetSessionData>) => createQueryKey('getSession', options);

/**
 * Get session
 * Retrieve details for a specific session.
 */
export const getSessionOptions = (options: Options<GetSessionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSession({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSessionQueryKey(options)
    });
};

export const extendSessionQueryKey = (options: Options<ExtendSessionData>) => createQueryKey('extendSession', options);

/**
 * Extend session
 * Extend the expiration of a specific session.
 */
export const extendSessionOptions = (options: Options<ExtendSessionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await extendSession({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: extendSessionQueryKey(options)
    });
};

/**
 * Extend session
 * Extend the expiration of a specific session.
 */
export const extendSessionMutation = (options?: Partial<Options<ExtendSessionData>>): UseMutationOptions<ExtendSessionResponse, DefaultError, Options<ExtendSessionData>> => {
    const mutationOptions: UseMutationOptions<ExtendSessionResponse, DefaultError, Options<ExtendSessionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await extendSession({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSettingsCatalogQueryKey = (options?: Options<GetSettingsCatalogData>) => createQueryKey('getSettingsCatalog', options);

/**
 * Settings catalog
 * Retrieve available settings definitions and defaults.
 */
export const getSettingsCatalogOptions = (options?: Options<GetSettingsCatalogData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSettingsCatalog({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSettingsCatalogQueryKey(options)
    });
};

/**
 * Delete current user's account
 * Permanently delete the authenticated user's account after validation checks.
 */
export const deleteAccountMutation = (options?: Partial<Options<DeleteAccountData>>): UseMutationOptions<DeleteAccountResponse, DefaultError, Options<DeleteAccountData>> => {
    const mutationOptions: UseMutationOptions<DeleteAccountResponse, DefaultError, Options<DeleteAccountData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteAccount({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listApiKeysQueryKey = (options?: Options<ListApiKeysData>) => createQueryKey('listApiKeys', options);

export const listApiKeysOptions = (options?: Options<ListApiKeysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listApiKeys({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listApiKeysQueryKey(options)
    });
};

export const listApiKeysInfiniteQueryKey = (options?: Options<ListApiKeysData>): QueryKey<Options<ListApiKeysData>> => createQueryKey('listApiKeys', options, true);

export const listApiKeysInfiniteOptions = (options?: Options<ListApiKeysData>) => {
    return infiniteQueryOptions<ListApiKeysResponse, ListApiKeysError, InfiniteData<ListApiKeysResponse>, QueryKey<Options<ListApiKeysData>>, number | Pick<QueryKey<Options<ListApiKeysData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListApiKeysData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listApiKeys({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listApiKeysInfiniteQueryKey(options)
    });
};

export const createApiKeyQueryKey = (options: Options<CreateApiKeyData>) => createQueryKey('createApiKey', options);

export const createApiKeyOptions = (options: Options<CreateApiKeyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createApiKey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createApiKeyQueryKey(options)
    });
};

export const createApiKeyMutation = (options?: Partial<Options<CreateApiKeyData>>): UseMutationOptions<CreateApiKeyResponse2, CreateApiKeyError, Options<CreateApiKeyData>> => {
    const mutationOptions: UseMutationOptions<CreateApiKeyResponse2, CreateApiKeyError, Options<CreateApiKeyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createApiKey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteApiKeyMutation = (options?: Partial<Options<DeleteApiKeyData>>): UseMutationOptions<DeleteApiKeyResponse, DefaultError, Options<DeleteApiKeyData>> => {
    const mutationOptions: UseMutationOptions<DeleteApiKeyResponse, DefaultError, Options<DeleteApiKeyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteApiKey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiKeyQueryKey = (options: Options<GetApiKeyData>) => createQueryKey('getApiKey', options);

export const getApiKeyOptions = (options: Options<GetApiKeyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiKey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiKeyQueryKey(options)
    });
};

export const revokeApiKeyQueryKey = (options: Options<RevokeApiKeyData>) => createQueryKey('revokeApiKey', options);

export const revokeApiKeyOptions = (options: Options<RevokeApiKeyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await revokeApiKey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: revokeApiKeyQueryKey(options)
    });
};

export const revokeApiKeyMutation = (options?: Partial<Options<RevokeApiKeyData>>): UseMutationOptions<RevokeApiKeyResponse, DefaultError, Options<RevokeApiKeyData>> => {
    const mutationOptions: UseMutationOptions<RevokeApiKeyResponse, DefaultError, Options<RevokeApiKeyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await revokeApiKey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLoginAttemptsQueryKey = (options?: Options<GetLoginAttemptsData>) => createQueryKey('getLoginAttempts', options);

/**
 * List recent login attempts
 * Retrieve recent login attempts for the authenticated user, including failures.
 */
export const getLoginAttemptsOptions = (options?: Options<GetLoginAttemptsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLoginAttempts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLoginAttemptsQueryKey(options)
    });
};

export const getLoginHistoryQueryKey = (options?: Options<GetLoginHistoryData>) => createQueryKey('getLoginHistory', options);

/**
 * List recent login history
 * Retrieve recent login history entries for the authenticated user.
 */
export const getLoginHistoryOptions = (options?: Options<GetLoginHistoryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLoginHistory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLoginHistoryQueryKey(options)
    });
};

/**
 * Change current user's password
 * Change the authenticated user's password by providing the current and new password.
 */
export const changePasswordMutation = (options?: Partial<Options<ChangePasswordData>>): UseMutationOptions<ChangePasswordResponse, ChangePasswordError, Options<ChangePasswordData>> => {
    const mutationOptions: UseMutationOptions<ChangePasswordResponse, ChangePasswordError, Options<ChangePasswordData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await changePassword({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProfileQueryKey = (options?: Options<GetProfileData>) => createQueryKey('getProfile', options);

/**
 * Get current user's profile
 * Fetch the authenticated user's profile, including org memberships and verification status.
 */
export const getProfileOptions = (options?: Options<GetProfileData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProfile({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProfileQueryKey(options)
    });
};

/**
 * Update current user's profile
 * Update the authenticated user's name and/or email. Triggers email verification if email changes.
 */
export const updateProfileMutation = (options?: Partial<Options<UpdateProfileData>>): UseMutationOptions<UpdateProfileResponse, DefaultError, Options<UpdateProfileData>> => {
    const mutationOptions: UseMutationOptions<UpdateProfileResponse, DefaultError, Options<UpdateProfileData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateProfile({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};